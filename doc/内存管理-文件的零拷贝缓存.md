# 文件的零拷贝缓存

在FTL OS全面懒执行后，整个程序的代码段，数据段都是文件映射。但文件映射依然要访问文件，依然需要一次缓慢的拷贝操作来把它映射到内存中。有没有什么方法可以绕过文件访问，同时O(1)地把文件映射进内存中完全绕过复制过程？听起来是不是有点共享映射的感觉了？没错！我们可以把文件也纳入共享映射，这样对于只读页面的映射就只是简单的复制而已，而对于可写的页面，我们也可以从缓存的页面直接复制，完全绕过文件访问。

## 共享页的多核预读

多核复制的尝试是失败的，但思路是可以借鉴的。我们为什么需要复制页面？因为共享页面不具有可写权限，如果我们想获取一个可写权限的页面，那么必须先从共享页面复制到一块新的内存。这次复制是不可避免的。

真的不可避免吗？确实。但它必须要发生在主进程上吗？我们完全可以由其他的核心预先完成页面的复制，并把它放在“所有权页面缓存”中。当主线程真的需要这个页面时，大可以直接从这个缓存中获取，如果缓存不存在，再自己复制一个页面。

这个方案下主核心完全不存在竞争开销，因为我们可以让繁忙的核心专注于自己的事，让其他核心专注于页面复制。缓存可以不止一个，缓存的所有权页面越多CPU的并发程度就越大。

## 进程的异步析构

我们发现使用了多核预读后execve+exit的测试性能还是没有太大提高。这是为什么？在测量了程序运行的每个部分后，我们发现进程退出时析构部分耗时较长。这部分耗时能不能避免？

多核预读是通过提前创建的方式避免主进程的延迟。那么析构能不能通过延迟的方式避免主进程延迟呢？显然是可以的。我们只要把待析构的`AliveProcess`作为一个“内核进程”发送给调度器，这样析构与主线程就解耦了。

尽管FTL OS只需要一行代码就可以生成一个异步线程，但有没有更方便的方式实现异步析构呢？首先我们要分析退出的过程是如何影响父进程的，在进程退出的时候会向父进程发送信号，然后父进程才能开始运行。如果我们在析构之前向父进程发送信号，析构过程就和父进程不再有时间上的关联了。

### 优化结果

fork+exit测试从150us降低到了114us，execve+exit测试从1039us降低到了1000us，execve的性能还是没有取得显著提高，fork的性能提高显著，但由于原得分已经远超基准线，总分提升并不明显。

## 物理页共享

共享页依然需要原子计数，即使采用了多核预读开销依然非常大。

注意到，在LINUX中，文件只要持有引用计数，它永远都不会关闭。能不能用这个来做些文章？mmap保证了偏移一定是对齐到页面大小的，我们可以直接让页面指向那块内存，而句柄保证了文件不关闭。这样引用计数就完全不存在了！