# FAT32文件系统

FTL OS的FAT32文件系统是异步文件系统，支持完善的多核并发操作，缓存块管理和无阻塞写与异步IO。

文件系统按模块可划分为：

| 模块     | 用途              |
| -------- | ----------------- |
| layout   | 磁盘数据布局定义  |
| block    | 缓存块管理        |
| fat_list | FAT簇分配链表管理 |
| inode    | FAT inode管理     |
| manager  | FAT32文件系统接口 |

## 利用linux生成FAT32文件系统

使用mount系统调用可以把文件挂载到一个目录下。但在这之前还需要把文件按文件系统格式化。

```
dd if=/dev/zero of=fat32.img bs=40M count=1mkfs.vfat -s 8 -F 32 fat32.img
```

`-s 8`指定了一个簇为8个扇区，`-F 32`指定了fat32文件系统而不是fat8或fat16。fat32文件系统的最小大小为32MB，小于或等于这个大小将创建失败。

使用mount挂载到一个目录下，这里设为img_test。

```
mkdir ./img_test
sudo mount -t vfat -o user,umask=000,utf8=1 --source fat32.img --target img_test
```

之后就可以用touch mkdir等指令在fs-img内部按fat32标准创建文件了！umount后即可取走fs-img去做其他事情了。

## 磁盘布局

### MBR(Main Boot Record) 主引导记录 446字节

MBR是计算机启动加载，解释分区结构，包含物理上的0扇区。

### DBR(DOS Boot Record) DOS引导记录

DBR是操作系统访问的第一个扇区，用来解释文件系统。这里的第一个扇区作为逻辑0扇区，接下来的描述以此为基准，访问扇区时要偏移。

### FAT table

这个表维护的是簇。取值如下：

| 簇号         | 描述   |
| ------------ | ------ |
| 0            | 空闲   |
| <0x0FFFFFF7  | 后继   |
| 0xFFFFFFF7   | 坏簇   |
| \>0x0FFFFFF7 | 无后继 |

FAT表中0号位与1号位是无效的，0号位的值永远为0xF8FFFF0F，1号位的值为0xFFFFFFFF/0xFFFFFF0F。

### 短文件名与长文件名

一个文件名项占用空间为32字节，因此一个4KB的簇可以放置128个项。短文件名格式为8.3（字节数），文件名部分不可为空，如果扩展名为空则输出的文件名不包含末尾的点，因此短文件名不能表示除了"."与".."之外末尾包含点的文件名。文件名项第一个字节为0x00时表示空闲，0xE5表示文件名项已释放。如果包含0x40位且不包含0xA0位说明是最后一个长文件名，此时低五位为顺序号。

无扩展的短文件名不能出现小写字母，因此出现小写字母就要使用长文件名表示，对应的短文件名将变为大写字母。windows支持短文件名中的保留标志位中文件名大小写扩展，全小写文件名可以只用一个短文件名表示。

一个长文件名项可以储存13个utf-16编码字符。当无法正好填充时，下一个位置将填充0x0，之后的空闲位置填充0xffff。

## 基于try的目录扫描

Haskell中惰性求值是一项基础语言特性，惰性求值过程只会数据结构的必要部分求值，利用惰性求值Haskell可以表示出无限链表等在普通语言中难以做到的数据结构。rust的标准库也提供了惰性求值支持，相对于Haskell，rust只能在函数中显式返回，而问号语法为此提供了便利。

```rust
    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
    where
        Self: Sized,
        F: FnMut(B, Self::Item) -> R,
        R: Try<Output = B>,
    {
        let mut accum = init;
        while let Some(x) = self.next() {
            accum = f(accum, x)?;
        }
        try { accum }
    }
```

这是标准库中try_fold的函数定义。在`f(accum, x)?`处会对返回值进行判断，如果返回值为`Try::Residual`，try_fold将直接返回。

FTL OS文件系统中广泛使用了try_fold对数据进行操作。使用try_fold而不是迭代器的原因是try_fold和迭代器运行的位置不同，try_fold的参数函数运行在栈的最深处，而迭代器是从函数的返回值中获取值。try_fold可以作为深层异步函数的一个部分运行，而迭代器除了需要将自身异步化外，每次调用都涉及内部上下文的切换，在文件系统中的表现为try_fold只需要获取锁一次，而迭代器每次取出数据都要获取锁，除了开销更大外还导致了潜在的数据不同步问题。

# 文件系统设计--缓存块层

## 异步读写

FTL OS的异步

CPU不再等待缓慢的磁盘操作，而是提交读写申请后就切换上下文。

磁盘操作不能共享内存，但可以转移所有权。（驱动读完后直接转移内存块到缓存中）

驱动以中断方式通知文件系统磁盘操作完成。

## 磁盘写

磁盘写操作需要保证缓存内存全程不被改变。

#### 写策略A：

写磁盘时锁住这个缓存块，在完成写入之前禁止操作这个内存。

阻塞导致延迟极高。

#### 写策略B：

写磁盘时把内存复制到新的内存送给写驱动。

无阻塞也需要额外复制，无竞争的性能下降。

#### 写策略C：

写时复制，当对此内存块进行写操作时复制一份新的内存。驱动上的内存操作完成后直接释放。

无阻塞且无竞争下无开销，非常完美。

### 磁盘读

无阻塞读是不可能的。

获取睡眠锁后提交驱动即可。

## 内存上的FAT

FAT初始化时整体缓存，反正也不大。在时钟中断时对脏块写回。

## 缓存块设计

缓存块操作单位为簇，读写提交将一次性处理多个扇区。

每个缓存块包含4KB的对齐缓存页，以及一个睡眠锁。文件系统禁止多个进程同时操作一个文件，任何进程尝试对缓存块操作都需要获取睡眠锁。

缓存块包含引用计数。此引用计数的增加必须在管理系统中增加，被全局锁保护。递减不需要锁保护，且递减完成后不会进行任何操作。缓存块的释放在管理器中无空闲缓存块时一次性回收。缓存块从管理系统获取后对它的相关操作即和管理系统解耦。

设计文件系统可以使用至多10%内核内存。文件系统内部操作全部无阻塞。

从文件系统获取未上锁的缓存块是无阻塞的。当文件系统使用内存达到上限时直接拒绝操作。新缓存块在加载数据之前不分配内存页，只有获取睡眠锁后才申请内存。即使引用计数为0也不释放内存，内存的释放在管理系统中进行。

新板子才32MB的缓存？我有个大胆的想法，能不能整个放进内存中？关机了再同步。

时钟中断定期将脏的无引用缓存块写回，在DMA空闲时才会进行此操作。

缓存块锁不会被进程一直持有。只有设计磁盘文件操作时才进行，通常为打开或关闭文件时。（打开完成后锁就扔了！关闭文件写回时再获取一次锁）

关闭文件写回时不需要从磁盘读取数据。

## 日志系统

似乎很复杂。初始不引入。

## 磁盘读写模型

### 读磁盘

从磁盘读数据显然不能无阻塞地进行，但可以出让CPU，把任务交给DMA。

FTL OS缓存块读请求阻塞于当前进程任务。

### 写磁盘

写磁盘可以不阻塞地进行，只要把当前数据复制一份交给驱动。

当前FTL OS写磁盘请求将产生一个新的task放入调度器。这些task很可能阻塞在驱动睡眠锁中。为了充分利用驱动资源，应该使用信号量来将多个请求加入DMA队列，否则睡眠锁调度阶段DMA无法利用。

### 数据预读

读磁盘阻塞进程效率太低，是否可以像写磁盘一样填满DMA队列，使睡眠锁调度时DMA依然可以工作？

使用数据预读预测连续读，当检测到连续读时提前将下一个簇的读请求加入调度器。

## 缓存同步模型

缓存块携带状态标志，None表示需要从磁盘读，Clean表示不需要同步，Dirty表示需要写回磁盘。

创建文件时不需要从磁盘读数据，但由于需要写回，标记为Dirty。

umount将阻塞等待所有写任务操作完成。

## 缓存块分配的初始化

新分配的簇需要初始化（可选）。如何保证这个簇在首次使用时被初始化?

分配缓存块从FAT表进行。获取缓存块在缓存管理器中进行。FAT表和缓存块管理器分属不同的锁。

## 方法1

释放块时清0，保证文件系统未使用的部分都为0。速度非常慢！而且不能保证新的文件系统拿到的都是0。

## 方法2

分配块时清零，为了保证保证原子性，需要在持有FAT表锁的情况下获取缓存管理器的锁。需要严格确保按顺序获取锁。

## 方法3

为什么要把FAT表和块管理器分开？如果一起上锁就没什么原子性的事了。

FAT表和缓存管理器总是成对使用，很少有单独使用的情况。

## 如何在初始化时不加锁？

众所周知，缓存块持有的是睡眠锁，而FAT表等使用的是自旋锁，不可能在初始化时获取睡眠锁。

将初始化操作作为函数放入，释放锁后首个获取缓存块的在睡眠锁内调用此函数。

# 文件系统设计--多核优化

文件系统内部不使用缓慢的关中断自旋锁。由操作系统保证使用文件系统时关中断。

## 无锁FAT表

FAT表是一张表，如果看作是一个对象，那每次操作都加锁是理所当然的。

但是，如果把FAT表看作是一块内存呢？

FAT上有很多的链表，但这些链表毫无关联，这意味着这些链表的操作根本互不影响！

唯一对FAT表的操作只有分配和释放簇。但分配释放簇根本不会影响到其他的链表，完全不需要锁上其他的链表。只要保证操作链表的排他性即可，这将由inode保证。

FAT表的磁盘同步需要获得一份当前状态的完整复制。注意到FAT表的修改全部在簇分配器中进行，因此磁盘同步的时候只要把簇分配器锁上就行了。

FAT表无锁化后全部进程即可无竞争地访问整个磁盘的任何位置，无论这个链表有多长。

此操作需要保证整个FAT表都保存在内存中。如果磁盘大小为1GB，簇为4KB，每个簇需要4B的簇号，那么1GB的磁盘需要1MB的FAT表。完全够用！

## 完全无竞争的缓存块索引

当前FTL OS使用的单个缓存块分配器，众所周知，获取缓存块是要加锁的。有什么办法可以完全无锁地获取已存在的缓存块吗？

众所周知，rust有个叫做Arc的智能指针。但是rust还有个东西叫Weak指针，Weak指针可以转变为Arc指针访问。是否可以利用这一点，开一个和簇数量一样多的Weak数组，搜索缓存块时先从Weak中尝试转变为Arc，如果失败了再从全局缓存块分配器中分配一个缓存块并更新Weak数组？

这需要多少内存？首先需要了解为什么Arc析构后Weak指针依然可以正常访问地址，这是因为Arc把对象的析构分成了两部分，调用析构函数和释放内存。当强引用计数为0时会调用析构函数，但为了保证Weak依然指向有效地址，需要等待全部Weak指针析构后才释放内存。而如果把Weak开在一个数组上，那么这些内存就永远不会释放了。

可能的方法是在删除旧缓存块时也将索引中的Weak指针复位，这样就能释放僵尸内存了。

每个Weak指针大小为8字节。占用大小为FAT表的两倍。

### Weak指针的更新

如果Weak指针指向有效缓存块，那自然非常完美。但多核下会出现如下情况：

#### 核A将Weak写入新的数据，核B的高速缓存还没有观测到新的值。

核A写入Weak后，Weak指向内容从p1变为p2，核B观测到了p1。此时核A由于删除了p1的最后一个weak，内存被释放。核B对p1的取值将取到无效内存。

#### C++中的atomic_weak_ptr

如果在rust中实现了此部分，就可以完全无锁地操作weak指针了！

看了看它的源码，它也使用了锁，只不过把锁放在了堆上。

#### 有锁的Weak

通常实现锁需要原子变量，大小为1字节。但weak对齐到8字节，如果使用一般的锁会占用2倍的空间。

考虑另外开一个锁数组，每个簇使用1字节的空间。每次访问Weak都要先上锁。

rust Weak类型实现为NonNull。是否可以把0作为锁标志？（非常unsafe）

#### weak的操作细节

weak初始化为默认值(-1)。每次获取缓存块后在分配器内部加锁更新weak数组。

访问weak时需要先获取锁，再取出weak，进行upgrade操作，释放锁。

如果weak获取失败并不意味者缓存块不存在，可能只是weak还没有来得及更新。但即使获取失败了，依然可以进入块管理器获取缓存块。

## 基于哈希的高速inode管理器

inode将簇号作为ID，这意味着可以直接将ID作为哈希输入，分给对应的管理器管理。

为了降低锁竞争，使用128个分配器，反正内存不值钱。

# 文件系统设计-文件inode

全部的inode在同一个有锁的管理系统中管理。但管理系统只在获取和释放中被使用，开销很低。

inode拥有FAT表中对应链表的绝对所有权，对链表上数据的访问全部通过inode进行，拥有链上数据一致性的保证需求。

inode允许由Arc被多个进程持有，但一条数据链永远只有一个inode。不同的inode属于不同的链，相互之前完全没有关系。

## 链上数据一致性

整条链上唯一可能出错的位置是链的增长和缩短。簇分配器保证了分配的原子性，保证了FAT表操作的绝对正确性。

如何保证对inode的操作被多个进程感知，例如链的缩短如何通知到所有进程？

inode操作使用读写睡眠锁。

inode上有一个文件长度项，当只读或写操作偏移量结束长度小于此长度时尝试持有共享锁，否则持排他锁。

inode上有一个list版本号，只有链的长度缩短时才会改变版本号，每个进程将持有一个版本号副本，当版本号不匹配时将丢弃当前缓存的簇号，从头开始寻址。

## inode操作细节实现

读：获取inode共享锁 - 检查/获取簇号 - 获取缓存块共享锁

写（区域）：获取inode共享锁 判断长度，如果长度不足则释放共享锁再获取排他锁分配充足的空间并直接写入

写（末尾）：获取inode排他锁 分配簇 更新文件长度 离开后更新目录项长度

修改长度：获取inode排他锁 分配 / 释放簇 设置版本号 更新文件长度 离开后更新目录项长度

### 文件操作后如何更新目录项？

inode保存所在目录的簇号和它的偏移，释放各个锁后获取根目录inode并进行扫描修改。

需要检测根目录簇号是否有效！

如果短文件名匹配失败则丢弃这个文件。（理论上不会出现，无法改变打开的文件的位置）

#### 获取目录项需要释放锁，如何保证目录项更新时拿到最后一个长度？

在释放读写锁之前获取时间，当目录项修改更晚但小于1分钟时放弃修改。

### 文件打开后从根目录移走了怎么更新？

禁止移动正在打开的文件。（移动上层目录没问题）

## 文件系统设计-目录inode操作

### 删除一整个目录与全部文件需要做什么？

不要把要删除的目录作为操作对象，要把要删除目录的根目录作为操作对象。

禁止函数递归实现，不然内核栈分分钟爆给你看。

锁定要删除的目录，禁止文件系统访问此目录。

使用Vec<簇号>模拟栈，栈内放了递归到达的目录文件与扫描到的偏移。扫描（不出栈）栈顶目录项的文件时：

1：检测此文件是否打开与相关权限，出错则返回

2：如果是目录则入栈，重新取其进行扫描。

3：如果是文件则释放。

4：扫描到块末尾则出栈，删除此刻栈顶目录的对应项。重新开始上述过程直到栈空

5：栈空了！此时待删除文件已经是空的了，将其删除即可。

## 对目录路径A->A'...->B->B'...

### 两个核a、b同时启动全部删除A'和B'的任务

#### 目标

当B'任务未完成时，尝试删除B时应该失败，不再尝试继续删除。先前的操作不需要撤销。

当删除操作未完成时，禁止新的任务访问此目录。

#### 解决方法

b一直持有B的inode。禁止a删除存在打开的inode的目录项。

当某个目录的删除操作尚未完成时，禁止删除根目录。（禁止删除非空文件）

这会导致无法同时发起同一个目录下两个文件夹的删除，不过没什么大不了的。

### inode排他锁

当获取排他inode锁后即获得了整条链上全部缓存块的所有权。逻辑上获取缓存块锁绝对不会失败。

### 缓存块排他应用锁

普通排他锁默认此块会修改，这会修改脏标志位导致需要写回。而排他应用锁只会在满足应用条件时增加脏标志位。

### 同时在一个目录创建新文件

使用inode共享锁 缓存块排他应用锁，当需要新的空间时再获取排他inode锁，一次性创建。

### 同时在一个目录查找/读文件

共享inode锁共享块锁读取出项即可。

### 同时在一个目录删除文件

使用共享inode锁排他应用锁修改对应项。第二个核不会已删除的文件。

# 超大磁盘空间优化

假设簇大小为4KB，对1TB的磁盘，以上优化导致需要的内存大小为：

FAT表内存：1GB

Weak缓存块无竞争索引：2GB-10GB （初态和全被使用过）

Weak锁：256MB

磁盘刚刚挂载就需要3.25GB的内存，如果来个全盘搜索就会用掉11.25GB的空间。

是否可以使用类似缓存块的方式处理这么多的项？

## 缓存块索引单元

FAT表可以复用缓存块，因此只处理Weak索引。

缓存单元包含4KB的Weak指针数组，即512个。以及512B的Weak锁。

### 缓存块索引单元Weak索引

缓存块索引单元单元使用放置在内存上的Weak索引，由全局分配器负责分配。

### Weak索引占用的内存

那么1GB的FAT表拥有256K个簇，每个扇区的Weak使用8B的空间，占用的内存为2MB。

### 二级索引VSMap索引

两边都使用读写自旋锁，只读时锁竞争为0。

weak指针upgrade+锁=3次原子操作 二级索引导致6次原子操作

如果不使用索引而是全局有锁Map<CID,Weak>，只需要1次upgrade和锁=3次原子操作。

3次原子操作开销少于Map增加的开销。

缺点：索引块替换将导致对应的索引全部失效，但有锁Map一直有效。

二级索引的内存开销是Map索引的几十倍。

Map索引的代码好写程度是二级索引10倍。现阶段使用Map缓存块索引。

## 使用FAT缓存单元后的缓存块获取

### 访问第n个簇

1.  计算索引单元索引，有锁地将Weak指针upgrade为Arc，立刻释放锁。成功转3。

2.  upgrade返回了None，此时从索引单元管理器分配并更新，可能会释放某个索引。

3.  计算索引单元内索引，有锁地将对应Weak指针upgrade为Arc，立刻释放锁。成功转5。

4.  持有着索引单元Arc不释放，从全局缓存块分配器获取缓存块空间，更新索引单元。

5.  取走缓存块的Arc，潇洒地离开。


## FAT链表缓存块

将FAT链表扇区使用Weak指针索引，由全局FAT链表扇区管理器分配空间。

## 索引访问的LRU更新

### 通过索引访问的块不经过管理器，如何确保找到的缓存块是不被使用的？

寻找强引用计数为1的指针，使用try_unwrap()尝试取出缓存块，如果成功则修改缓存块信息，尝试删除旧的Weak，否则把失败返回的Arc则放回管理器。

### 如何找到“很有可能”是最后一次未使用的缓存块？

每个缓存块都维护了一个访问序列ID，使用Arc<AtomicUsize>.fetch_add无锁获取。

所有缓存块放置在Map<ID,Arc<cache>>的映射中，每次取出ID最小的项，判断ID和cache是否相等，如果不相等则放回对应时间的位置。

ID匹配后取出Arc并try_unwrap，如果失败了再获取一次ID并赋值（当前cache的ID可能还没被使用方更新），放入Map，成功则将此作为替换块。

此方法有小概率在判断ID相等后某进程从Weak获取Arc，更新时间，释放Arc一气呵成，然后本进程成功从Arc取出cache，但这种小概率事件发生了也仅仅是LRU违例降低效率，不会影响内核的安全。

### 如何防止还没有同步的缓存块被替换？

禁止替换脏标志位的缓存块。同步系统优先同步最后一次未使用的缓存块。

管理系统增加成员保存当前同步到的时间，同步系统从此时间开始搜索。

### 如何同步缓存块？

使用一种简单但有效解决饥饿的同步方法。维护两个集合S1和S2，S1是本次同步的集合，S2是下次同步的集合。

每个块脏标志改变时都会加入S2，而同步系统完成S1同步就会移动S2至S1，开始S1的同步。

# 缓存块同步系统

## 无阻塞写且磁盘太慢导致的缓存块不足

如果磁盘速度太慢，所有缓存块都含脏标志位，无法分配缓存块。

方法A：阻塞尝试分配缓存块的进程。

缓存块分配使用异步分配。当所有块都为脏或不在允许ID队列中时加入等待队列。

方法B：信号量阻塞正在疯狂写的进程，不让全部缓存块都是脏的。

缓存块共享一个信号量，尝试写入时需要先获取信号量，驱动完成缓存块写入时返还信号量。

信号量的值可以设置为内存的1%。

使用方法B。

## 数据结构

最大脏块数：允许的最大脏块数量

当前脏块数：如果小于这个数则不阻塞，并递增1。

## 信号量阻塞写入的操作顺序

1.  发起对缓存块的写入请求T，获取排他锁[await]。

2.  判断当前是否为脏状态，如果是则判断初始化，之后直接应用请求T，释放锁，结束。

3.  无脏标志。完成写入T，获取同步系统锁[await]+信号量[await]。

4.  修改脏标志，释放锁。


## 驱动中断驱动的同步系统操作顺序

中断处理程序不能完成

1.  驱动完成中断。

2.  获取同步系统自旋锁

3.  如果等待队列不为空则释放一个等待任务并更新相关标志，结束。

4.  如果等待队列为空则将脏块数减一，结束。


## 同步系统Future

自旋锁维护的包含：ID分配器，最大允许ID，等待队列，当前脏块数 最大脏块数

进入future：

判断是否首次进入：

首次进入则判断脏块数，成功则递增1，放行。不成功则阻塞，获取一个ID加入等待队列。

再次进入则判断ID是否不大于允许ID号，如果是则放行，否则阻塞。

## 释放信号量

释放信号量显然不需要阻塞，因此可以用在中断系统中。

获取同步系统锁，判断队列队列是否不为空：

如果不为空，则wake第一个任务，设置允许ID为此任务的ID。（保证ID递增）

如果不为空，则脏块数减一。

信号量由Guard保存，可以发送到同步任务中，任务结束了自动释放信号量。

# 使用上述全部优化后的文件系统总架构

## FAT链表相关

扇区缓存LRU管理器 最大使用2%系统内存。每项占用4.5KB的空间。

无竞争扇区缓存索引 占用空间为每扇区9B （8B指针+1B锁）

每个索引管理512B=128个簇号=512KB空间 需要空间1KB

1TB磁盘需要索引数组内存为18MB

FAT链表的修改全部通过管理器进行，因此管理器可以维护所有需要同步的扇区。

## 缓存块索引相关

缓存块索引LRU管理器 最大使用2%系统内存。每项占用4.5KB的空间。

无竞争缓存块索引的索引 9B每单元512个缓存块Weak索引（4KB+512B）

无竞争缓存块索引 9B每单元 =>4KB簇

1TB磁盘含256M个簇，需要512K个索引的索引 占用内存为4.5MB。

## 簇缓存相关

缓存块LRU管理器 最大使用10%系统内存。每缓存块占用4.5KB的空间。

包含指向inodeCache的Weak指针，只有FAT链表的首个簇的块缓存才有效。

共享-排他睡眠锁。

脏标志位。

基于共享COW缓存的无阻塞磁盘同步。

### 簇同步系统

所有脏标志的改变都需要先获取信号量。驱动写完成了需要回调。

设置初始化标志也需要获取信号量！

## inode相关

InodeCache LRU管理器，读写自旋锁，最大使用2%系统内存，每个InodeCache占用16KB。

InodeCache的索引放在FAT链表首个簇的缓存块上，缓存块/索引无效则从管理器中获取。

InodeCache内部缓存数据都由常规自旋锁保护。

懒加载的FAT链表缓存(读写自旋锁保护) -- inode引用计数为0也存在 8KB

缓存前1K个簇（占用4KB 对应磁盘空间16MB）

缓存每1K个簇的簇号，即1K 2K 3K..

缓存最后一个簇的簇号和它是第几个簇

禁止拿着缓存锁去获取磁盘FAT信息（磁盘FAT信息需要睡眠锁）

FAT链表读写-排他睡眠锁 改变FAT链表长度时必须获取排他锁

inode是文件打开的唯一标识，inodeCache是获取inode的唯一途径，inode不保存在任何的全局管理器中，这意味着InodeCache中的inode Weak指针无效即证明此文件没有被打开。打开inode的方法只有先从管理器获取inodeCache，再从inodeCache获取inode。

InodeCache持有根目录簇地址和对应InodeCache的Weak指针，所在目录项的偏移量，因此文件修改路径后需要修改或删除InodeCache。

Inode保存了此文件所属的目录对应InodeCache的Arc指针，防止根目录被删除/回收并方便地修改访问信息并防止文件打开时根目录被删除。

Arc<InodeCache>的持有者只有3个：

inode管理器、inode(进程打开的)、目录下级打开的文件的inode。

不能由打开的文件的InodeCache持有根目录的Arc指针，这会导致文件关闭后依然无法删除。

### 数据结构

管理器持有InodeCache的Arc。无进程时引用计数为1，由Arc::try_unwrap获取

进程持有的Inode的Arc。inode将在无进程时释放

Inode包含指向Inode的Weak。

Inode包含指向InodeCache的Arc。

首个簇包含指向InodeCache的Weak。

### 进程索引访问文件inode（文件/目录）

文件簇号是唯一标识，如果没有簇号，一个空文件根本没必要索引。

从目录项拿到簇号后：

通过索引尝试访问缓存块（获取缓存块不需要加载内容！）。

如果成功了尝试upgrade内部的inodeCache Weak指针。

如果上述操作失败了从inode管理器获取inodeCache的Arc指针。

尝试upgrade inodeCache中的raw_inode指针，如果失败了则创建一个新的raw_inode。

### inode缓存

保存最近一次读写非append读写的偏移量-簇号映射

## 空文件

如果某个文件是空的，FAT32此时簇号为0，那簇号不再能作为标识符了，如何处理多个进程打开空文件的情况？

解决方法A：没有簇号就给你簇号，打开空文件时强行分配一个簇，短文件名长度写入4096，写回时判断长度是否为0，如果为0就把这个簇释放了，并把文件长度改为真实长度。

移动文件后只需要改变父目录指针。

解决方法B：不使用CID作为标识符，而是使用短文件名地址(簇号,偏移)作为标识符。

需要保证打开的文件位置不会移动，移动文件时需要修改缓存管理器。

## RawInode

提供inode公共操作，使用睡眠锁保护。读和写使用同一个指针。

偏移量顺序读：共享锁 自带当前偏移量指针缓存

偏移量写：无锁获取当前长度判断是否在文件内 共享锁 二次判断 需要修改文件大小则为排他锁。偏移量不能大于文件大小，否则操作失败。（文件扩充要求）

末尾写：排他锁写 修改目录项 FAT链表

窗口读写：原子地将闭包以窗口方式访问块并进行相关读写。

## 目录inode

允许同时锁定多个缓存块，但绝不允许先锁定靠后的再锁定靠前的。

### 查找文件

获取inode共享锁 每个缓存块共享锁扫一遍即可

### 创建文件

获取inode共享锁找空位 缓存块使用排他锁 如果找不到则换成排他锁，分配新的空间后直接写入。

一次锁定相邻的两个块处理跨簇情况。

### 删除文件

获取inode共享锁查找，查到了则判断权限，在inode管理器中删除缓存。

只允许Arc::try_unwrap删除inode缓存。

可能同时锁定相邻的两个块，删除目录中的项，获取起始簇号，释放睡眠锁。

在FAT分配器中删除整条链表。

### 删除目录-强制

获取inode排他锁，不再允许其他进程访问此目录。

获取此目录缓存的引用计数。

使用模拟栈的方式深度优先地删除下层目录，只有要删除的目录为空时才能删除对应的目录。

### 文件位置移动 src => dst

不能乱序同时锁上两个移动的位置！否则分分钟死锁。

获取src的目录位置，持有一个Arc的inode引用。

inode共享锁检查src处文件是否存在，是否不被打开，记录所在偏移量，释放inode锁。

获取dst目录位置，持有一个Arc的inode引用。

按照CID从小到大的顺序给两个目录上inode排他锁。

根据记录的偏移找到src的名字项，在dst中分配一个位置，移动名字项。

在inode管理器中修改根目录簇地址和Weak指针项，如果缓存不存在则忽略。

如果是文件是目录，从簇地址直接获取对应缓存块把第一项的簇号与修改时间改了。无竞争保证：修改一个目录缓存块的唯一方式是通过inode或父目录，这个目录已经锁了。

释放两个锁，顺序任意，操作完成。

## 文件inode

非append操作：根据输入偏移量读写。

独立写：根据当前长度判断是否需要排他inode锁分配空间（只要文件变大了就要排他锁，即使不需要新的簇）。分配后改inode共享锁缓存排他锁写入即可。

独立读：使用inode共享锁和缓存块共享锁读取。

尾部写：忽略输入偏移量，使用排他inode锁，分配空间，修改长度，写入。

# 文件系统挂载

todo!() qwq

## 虚拟文件系统VFS

VFS提供了文件系统接口，操作系统对文件系统的操作从VFS进行。VFS挂载到某个目录下。





## 参考资料

# fat32文件系统

fat32 wiki: [https://wiki.osdev.org/FAT](https://wiki.osdev.org/FAT)

FAT32文件系统结构详解 [https://blog.csdn.net/li_wen01/article/details/79929730](https://blog.csdn.net/li_wen01/article/details/79929730)

FAT32长文件名短文件名目录项 [https://blog.csdn.net/u010650845/article/details/60780979](https://blog.csdn.net/u010650845/article/details/60780979)
