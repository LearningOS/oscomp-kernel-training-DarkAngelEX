# FAT32文件系统

FTL OS的FAT32文件系统是异步文件系统，支持完善的多核并发操作，缓存块管理和无阻塞写与异步IO。

文件系统按模块可划分为：

| 模块     | 用途              |
| -------- | ----------------- |
| layout   | 磁盘数据布局定义  |
| block    | 缓存块管理        |
| fat_list | FAT簇分配链表管理 |
| inode    | FAT inode管理     |
| manager  | FAT32文件系统接口 |

## 利用linux生成FAT32文件系统

使用mount系统调用可以把文件挂载到一个目录下。但在这之前还需要把文件按文件系统格式化。

```
dd if=/dev/zero of=fat32.img bs=40M count=1mkfs.vfat -s 8 -F 32 fat32.img
```

`-s 8`指定了一个簇为8个扇区，`-F 32`指定了fat32文件系统而不是fat8或fat16。fat32文件系统的最小大小为32MB，小于或等于这个大小将创建失败。

使用mount挂载到一个目录下，这里设为img_test。

```
mkdir ./img_test
sudo mount -t vfat -o user,umask=000,utf8=1 --source fat32.img --target img_test
```

之后就可以用touch mkdir等指令在fs-img内部按fat32标准创建文件了！umount后即可取走fs-img去做其他事情了。

## 磁盘布局

### MBR(Main Boot Record) 主引导记录 446字节

MBR是计算机启动加载，解释分区结构，包含物理上的0扇区。

### DBR(DOS Boot Record) DOS引导记录

DBR是操作系统访问的第一个扇区，用来解释文件系统。这里的第一个扇区作为逻辑0扇区，接下来的描述以此为基准，访问扇区时要偏移。

### FAT table

这个表维护的是簇。取值如下：

| 簇号         | 描述   |
| ------------ | ------ |
| 0            | 空闲   |
| <0x0FFFFFF7  | 后继   |
| 0xFFFFFFF7   | 坏簇   |
| \>0x0FFFFFF7 | 无后继 |

FAT表中0号位与1号位是无效的，0号位的值永远为0xF8FFFF0F，1号位的值为0xFFFFFFFF/0xFFFFFF0F。

### 短文件名与长文件名

一个文件名项占用空间为32字节，因此一个4KB的簇可以放置128个项。短文件名格式为8.3（字节数），文件名部分不可为空，如果扩展名为空则输出的文件名不包含末尾的点，因此短文件名不能表示除了"."与".."之外末尾包含点的文件名。文件名项第一个字节为0x00时表示空闲，0xE5表示文件名项已释放。如果包含0x40位且不包含0xA0位说明是最后一个长文件名，此时低五位为顺序号。

无扩展的短文件名不能出现小写字母，因此出现小写字母就要使用长文件名表示，对应的短文件名将变为大写字母。windows支持短文件名中的保留标志位中文件名大小写扩展，全小写文件名可以只用一个短文件名表示。

一个长文件名项可以储存13个utf-16编码字符。当无法正好填充时，下一个位置将填充0x0，之后的空闲位置填充0xffff。

## 基于try的目录扫描

Haskell中惰性求值是一项基础语言特性，惰性求值过程只会数据结构的必要部分求值，利用惰性求值Haskell可以表示出无限链表等在普通语言中难以做到的数据结构。haskell中foldr函数定义如下：

```haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
```

逻辑上foldr是对链表从右向左折叠，但在实际求值中是从左向右计算的。由于haskell的惰性求值特性，foldr中参数`f`可能不需要对`x:xs`求值，此时foldr不再需要遍历余下的链表，因此foldr有时可以输入无限列表，并在有限时间内返回结果。

rust的标准库也提供了惰性求值支持，相对于Haskell，rust只能在函数中显式返回，而问号语法为此提供了便利:

```rust
    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
    where
        Self: Sized,
        F: FnMut(B, Self::Item) -> R,
        R: Try<Output = B>,
    {
        let mut accum = init;
        while let Some(x) = self.next() {
            accum = f(accum, x)?;
        }
        try { accum }
    }
```

这是标准库中try_fold的函数定义。在`f(accum, x)?`处会对返回值进行判断，如果返回值为`Try::Residual`，try_fold将直接返回。foldr和try_fold并不等价，因为折叠的方向相同。

FTL OS文件系统使用try_fold封装对缓存块的操作，并在此基础上继续构造出一系列目录项处理操作。使用try_fold而不是迭代器的原因是try_fold和迭代器运行的位置不同，try_fold的参数函数运行在栈的最深处，而迭代器是从函数的返回值中获取值。try_fold可以作为深层异步函数的一个部分运行，而迭代器除了需要将自身异步化外，每次调用都涉及内部上下文的切换，在文件系统中的表现为try_fold只需要获取锁一次，而迭代器每次取出数据都要获取锁，除了开销更大外还导致了潜在的数据不同步问题。

## 缓存块层

文件系统采用异步驱动，因此缓存块读写也是异步化的。缓存块使用异步睡眠锁保护，当进程阻塞于睡眠锁时不会消耗CPU资源。缓存块只能经inode层修改，不暴露对外接口。

为了提高性能，文件系统使用无阻塞写策略，除了脏块到达上限外，inode写操作不会阻塞。为了实现无阻塞写，文件系统构建时将产生一个只运行在内核态的磁盘同步线程。每个磁盘写操作都会将缓存块标记为脏并提交至同步等待集合，磁盘同步线程则取出磁盘同步集合并对每个簇生成一个微线程，这为高性能并行IO提供了可能。最后一个微线程执行完成后会唤醒同步线程，同步线程将反馈同步结果至块缓存管理器，所有在同步期间没有被写入的缓存块的状态将变回clean。

多核环境中无阻塞写必须保证提交至驱动的内存处于不可变状态，即使缓存块在驱动写期间被其他线程修改。为了保证这一点，FTL OS使用了可以在唯一状态和共享状态自如转变的缓存。定义如下：

```rust
// fat32/src/block/buffer.rs
pub(crate) enum Buffer {
    Unique(Box<[u8]>),
    Shared(SharedBuffer),
}
#[derive(Clone)]
pub(crate) struct SharedBuffer(pub Arc<Box<[u8]>>);
```

缓存块的大小是可变的，在大多数文件系统中大小为4KB。`Buffer`可以在唯一状态和共享状态之间自由转换，且当引用计数为1时转变为唯一状态不需要复制内存，不为1时将分配新内存并从共享内存中复制资源。`Buffer`保证了唯一状态不存在其他的引用，共享状态的内存不会被修改。缓存块`Cache`使用睡眠读写锁封装`Buffer`，保证并发的安全。同步线程只需从可变的`Buffer`获取`SharedBuffer`即可保证数据不变性。

## 缓存块管理

磁盘的大小可能达到数个T，这种情况下缓存整个磁盘是不可能的，而缓存块有限时需要考虑缓存块的替换。无阻塞写策略下缓存块具有clean和dirty两种状态，而只有clean状态的缓存块是可以回收的，因此如果所有缓存块都为dirty，要么超出最大缓存块限制继续分配，要么阻塞获取操作直到某个dirty的缓存块同步完成。这会导致潜在的饥饿，因为如果缓存块在同步完成之前又被写入了，缓存块将依然处于脏状态。FTL OS使用信号量限制脏块数量保证不会到达缓存块数量上限，每个脏块都持有信号量，只有状态变回clean时持有的信号量才会释放。脏块数量限制不能保证可以找到一个可替换的块，因为只有不被持有缓存块才是可替换的。所有缓存块都被持有的概率很低，这种情况下文件系统将操作失败并返回ENOBUFS错误码。

FTL OS的文件系统使用RLU替换策略。缓存块管理器可以原子分配时间戳，缓存块具有一个时间戳字段。每次对缓存块的访问都会更新时间戳字段，但这个字段只会在缓存块替换时被访问。所有缓存块都处于按时间戳排序的有序集合中，但排序使用的排序时间戳仅保证不大于缓存块上的实际时间戳。替换时从时间戳的最小端开始寻找，只有排序时间戳和实际时间戳相等时才进行替换，否则更新排序时间戳并将缓存块放入正确的位置。这种替换方式里每次访问只有一次原子地址递增开销，但缓存块替换时开销较大，被访问的缓存块越多耗时越长。由于时间戳分配器是全局的，分配时间戳的竞争也非常大。

一种有效加速替换且减少竞争的方式是放弃LRU替换策略改为时钟替换策略，所有缓存块都放置在一个循环链表构成的时钟轮盘上，每个缓存块维护一个标志位。每次缓存块的访问都会将对应标志位设为1，而时钟经过缓存块时判断标志位，如果为0则直接替换，如果为1则改为0。这种方式在访问缓存块时只有一次额外访存开销，缺点是相对RLU会增加缓存块的查找和替换次数。当缓存块数量较多时替换次数将非常少，但减少的一次原子指令能明显提高性能。另一种方式是使用多代LRU算法，将所有缓存块放置在多条链表上，每次缓存块访问都会提升缓存块所属级别，但提升至最高级时不再提升，此时不再发生锁竞争。缓存块查找时只会在最低级的链表查找，当链表为空时所有链表都降低一个级别，此方法经过优化后可以在降低级别时不需要修改每一个缓存块上的信息，速度很快。

## 缓存块索引器

每个缓存块都对应一个磁盘上的簇，因此簇号是缓存块的唯一标识。获取缓存块自然可以在缓存块管理器中获取，但缓存块管理器被睡眠锁保护，竞争和锁开销非常大。为了提高性能，FTL OS在缓存块管理器的睡眠锁之外加入了缓存块索引器，查找缓存块时优先从索引器查找，当索引器查找失败时再进入缓存块管理器中查找缓存块。索引器定义如下：

```rust
// fat32/src/block/index.rs
pub(crate) struct CacheIndex(RwSpinMutex<BTreeMap<CID, Weak<Cache>>>);
```

可见索引器就是一个由读写自旋锁保护的映射。由于索引器只是不持有所有权的加速结构，因此映射结果也不持有所有权的弱指针。只有成功通过`upgrade`获取缓存块的强指针才是一次成功的索引器查找，索引器发生未命中则会在缓存块管理器进行缓存块查找，查找结束后将更新索引器，保证未命中至多在每个CPU发生一次。索引器在释放管理器睡眠锁后更新来减少缓存块管理器的持续占用，这可能存在由乱序更新导致的轻微内存泄露（长时间存在一个失效缓存块的索引），但不影响程序的安全性。

## 高并发的FAT表

许多文件系统的实现将FAT表看作一个对象并使用读写锁保护，例如2021届操作系统比赛冠军Ultra OS就使用了读写锁来保护FAT表。这样实现无可厚非，但FTL OS对FAT表有更进一步的高并发设计。FAT表在磁盘上占有大量的簇，将如此大的空间看作一个对象将极大地降低并发度，一个例子是两个互不相关的线程正在分别独立地读与写文件A与B，写文件B获取的FAT表写锁会阻塞读文件A，但这是两个不同的文件，拥有的FAT链表也是不相同的，为什么要相互干扰降低性能呢？FTL OS仅仅将FAT表看作一块磁盘上的空间，空间上分布了许多各自属于对应的文件的FAT链表，对一条链表的操作不会阻塞其他链表的操作。此设计下某文件分配簇的过程完全不会阻塞到其他文件对所属簇的读取，只要它拥有的链表存在于缓存中。

FTL OS的文件系统支持TB级磁盘，不会将整个FAT表放入内存。与缓存块不同，FAT表缓存以扇区为单位而不是以簇为单位，替换策略与缓存块一样使用LRU替换策略。FAT链表分配涉及大量数据修改不可并发，因此FAT表的磁盘IO和簇分配都在FAT表管理器中进行并由读写锁保护。

### FAT表索引器

FAT表索引器除了提供加速查找作用外，更重要的是它不处于管理器睡眠锁的作用范围，管理器处于占有状态时依然可以查找。由于FAT表的使用频率较大，索引器没有使用`BTreeMap`，而是使用了数组来实现O(1)的查找。索引器定义如下：

```rust
// fat32/src/fat_list/index.rs
pub(crate) struct ListIndex {
    weak: Box<[UnsafeCell<Weak<ListUnit>>]>,
    lock: Box<[RwSpinMutex<()>]>,
}

// fat32/src/fat_list/index.rs
pub(crate) struct ListUnit {
    buffer: UnsafeCell<Buffer>,
    aid: UnsafeCell<AID>,
}
```

索引器并不是对单个项的索引，而是对一个FAT表扇区`ListUnit`的索引。在文件系统中FAT链表的修改只能在FAT表管理器中进行，所有修改都是串行化的，因此这里系统使用了`UnsafeCell`来提高性能。和缓存块索引器一样，索引器的弱指针可能是无效的，此时需要进入FAT表管理器再次获取索引。索引器使用读写自旋锁的原因是多核环境下操作智能指针是不安全的，文件系统允许多个线程同时操作FAT表的同一个缓存扇区，由于CPU Cache的存在，写线程释放了旧的Weak指针后可能无法及时通知到读线程的Cache，此刻读线程将获取到一个已经被析构的弱指针，进行任何操作都会导致内核出错。最简单的解决方法就是上锁，不再赘述。另一个方式是使用RCU方式释放Weak指针，即使用如下的方式释放：



## 无锁FAT表

FAT表是一张表，如果看作是一个对象，那每次操作都加锁是理所当然的。

但是，如果把FAT表看作是一块内存呢？

FAT上有很多的链表，但这些链表毫无关联，这意味着这些链表的操作根本互不影响！

唯一对FAT表的操作只有分配和释放簇。但分配释放簇根本不会影响到其他的链表，完全不需要锁上其他的链表。只要保证操作链表的排他性即可，这将由inode保证。

FAT表的磁盘同步需要获得一份当前状态的完整复制。注意到FAT表的修改全部在簇分配器中进行，因此磁盘同步的时候只要把簇分配器锁上就行了。

FAT表无锁化后全部进程即可无竞争地访问整个磁盘的任何位置，无论这个链表有多长。

此操作需要保证整个FAT表都保存在内存中。如果磁盘大小为1GB，簇为4KB，每个簇需要4B的簇号，那么1GB的磁盘需要1MB的FAT表。完全够用！

## 完全无竞争的缓存块索引

当前FTL OS使用的单个缓存块分配器，众所周知，获取缓存块是要加锁的。有什么办法可以完全无锁地获取已存在的缓存块吗？

众所周知，rust有个叫做Arc的智能指针。但是rust还有个东西叫Weak指针，Weak指针可以转变为Arc指针访问。是否可以利用这一点，开一个和簇数量一样多的Weak数组，搜索缓存块时先从Weak中尝试转变为Arc，如果失败了再从全局缓存块分配器中分配一个缓存块并更新Weak数组？

这需要多少内存？首先需要了解为什么Arc析构后Weak指针依然可以正常访问地址，这是因为Arc把对象的析构分成了两部分，调用析构函数和释放内存。当强引用计数为0时会调用析构函数，但为了保证Weak依然指向有效地址，需要等待全部Weak指针析构后才释放内存。而如果把Weak开在一个数组上，那么这些内存就永远不会释放了。

可能的方法是在删除旧缓存块时也将索引中的Weak指针复位，这样就能释放僵尸内存了。

每个Weak指针大小为8字节。占用大小为FAT表的两倍。

### Weak指针的更新

如果Weak指针指向有效缓存块，那自然非常完美。但多核下会出现如下情况：

#### 核A将Weak写入新的数据，核B的高速缓存还没有观测到新的值。

核A写入Weak后，Weak指向内容从p1变为p2，核B观测到了p1。此时核A由于删除了p1的最后一个weak，内存被释放。核B对p1的取值将取到无效内存。

#### C++中的atomic_weak_ptr

如果在rust中实现了此部分，就可以完全无锁地操作weak指针了！

看了看它的源码，它也使用了锁，只不过把锁放在了堆上。

#### 有锁的Weak

通常实现锁需要原子变量，大小为1字节。但weak对齐到8字节，如果使用一般的锁会占用2倍的空间。

考虑另外开一个锁数组，每个簇使用1字节的空间。每次访问Weak都要先上锁。

rust Weak类型实现为NonNull。是否可以把0作为锁标志？（非常unsafe）

#### weak的操作细节

weak初始化为默认值(-1)。每次获取缓存块后在分配器内部加锁更新weak数组。

访问weak时需要先获取锁，再取出weak，进行upgrade操作，释放锁。

如果weak获取失败并不意味者缓存块不存在，可能只是weak还没有来得及更新。但即使获取失败了，依然可以进入块管理器获取缓存块。

## 基于哈希的高速inode管理器

inode将簇号作为ID，这意味着可以直接将ID作为哈希输入，分给对应的管理器管理。

为了降低锁竞争，使用128个分配器，反正内存不值钱。

# 文件系统设计-文件inode

全部的inode在同一个有锁的管理系统中管理。但管理系统只在获取和释放中被使用，开销很低。

inode拥有FAT表中对应链表的绝对所有权，对链表上数据的访问全部通过inode进行，拥有链上数据一致性的保证需求。

inode允许由Arc被多个进程持有，但一条数据链永远只有一个inode。不同的inode属于不同的链，相互之前完全没有关系。

## 链上数据一致性

整条链上唯一可能出错的位置是链的增长和缩短。簇分配器保证了分配的原子性，保证了FAT表操作的绝对正确性。

如何保证对inode的操作被多个进程感知，例如链的缩短如何通知到所有进程？

inode操作使用读写睡眠锁。

inode上有一个文件长度项，当只读或写操作偏移量结束长度小于此长度时尝试持有共享锁，否则持排他锁。

inode上有一个list版本号，只有链的长度缩短时才会改变版本号，每个进程将持有一个版本号副本，当版本号不匹配时将丢弃当前缓存的簇号，从头开始寻址。

## inode操作细节实现

读：获取inode共享锁 - 检查/获取簇号 - 获取缓存块共享锁

写（区域）：获取inode共享锁 判断长度，如果长度不足则释放共享锁再获取排他锁分配充足的空间并直接写入

写（末尾）：获取inode排他锁 分配簇 更新文件长度 离开后更新目录项长度

修改长度：获取inode排他锁 分配 / 释放簇 设置版本号 更新文件长度 离开后更新目录项长度

### 文件操作后如何更新目录项？

inode保存所在目录的簇号和它的偏移，释放各个锁后获取根目录inode并进行扫描修改。

需要检测根目录簇号是否有效！

如果短文件名匹配失败则丢弃这个文件。（理论上不会出现，无法改变打开的文件的位置）

#### 获取目录项需要释放锁，如何保证目录项更新时拿到最后一个长度？

在释放读写锁之前获取时间，当目录项修改更晚但小于1分钟时放弃修改。

### 文件打开后从根目录移走了怎么更新？

禁止移动正在打开的文件。（移动上层目录没问题）

## 文件系统设计-目录inode操作

### 删除一整个目录与全部文件需要做什么？

不要把要删除的目录作为操作对象，要把要删除目录的根目录作为操作对象。

禁止函数递归实现，不然内核栈分分钟爆给你看。

锁定要删除的目录，禁止文件系统访问此目录。

使用Vec<簇号>模拟栈，栈内放了递归到达的目录文件与扫描到的偏移。扫描（不出栈）栈顶目录项的文件时：

1：检测此文件是否打开与相关权限，出错则返回

2：如果是目录则入栈，重新取其进行扫描。

3：如果是文件则释放。

4：扫描到块末尾则出栈，删除此刻栈顶目录的对应项。重新开始上述过程直到栈空

5：栈空了！此时待删除文件已经是空的了，将其删除即可。

## 对目录路径A->A'...->B->B'...

### 两个核a、b同时启动全部删除A'和B'的任务

#### 目标

当B'任务未完成时，尝试删除B时应该失败，不再尝试继续删除。先前的操作不需要撤销。

当删除操作未完成时，禁止新的任务访问此目录。

#### 解决方法

b一直持有B的inode。禁止a删除存在打开的inode的目录项。

当某个目录的删除操作尚未完成时，禁止删除根目录。（禁止删除非空文件）

这会导致无法同时发起同一个目录下两个文件夹的删除，不过没什么大不了的。

### inode排他锁

当获取排他inode锁后即获得了整条链上全部缓存块的所有权。逻辑上获取缓存块锁绝对不会失败。

### 缓存块排他应用锁

普通排他锁默认此块会修改，这会修改脏标志位导致需要写回。而排他应用锁只会在满足应用条件时增加脏标志位。

### 同时在一个目录创建新文件

使用inode共享锁 缓存块排他应用锁，当需要新的空间时再获取排他inode锁，一次性创建。

### 同时在一个目录查找/读文件

共享inode锁共享块锁读取出项即可。

### 同时在一个目录删除文件

使用共享inode锁排他应用锁修改对应项。第二个核不会已删除的文件。

# 超大磁盘空间优化

假设簇大小为4KB，对1TB的磁盘，以上优化导致需要的内存大小为：

FAT表内存：1GB

Weak缓存块无竞争索引：2GB-10GB （初态和全被使用过）

Weak锁：256MB

磁盘刚刚挂载就需要3.25GB的内存，如果来个全盘搜索就会用掉11.25GB的空间。

是否可以使用类似缓存块的方式处理这么多的项？

## 缓存块索引单元

FAT表可以复用缓存块，因此只处理Weak索引。

缓存单元包含4KB的Weak指针数组，即512个。以及512B的Weak锁。

### 缓存块索引单元Weak索引

缓存块索引单元单元使用放置在内存上的Weak索引，由全局分配器负责分配。

### Weak索引占用的内存

那么1GB的FAT表拥有256K个簇，每个扇区的Weak使用8B的空间，占用的内存为2MB。

### 二级索引VSMap索引

两边都使用读写自旋锁，只读时锁竞争为0。

weak指针upgrade+锁=3次原子操作 二级索引导致6次原子操作

如果不使用索引而是全局有锁Map<CID,Weak>，只需要1次upgrade和锁=3次原子操作。

3次原子操作开销少于Map增加的开销。

缺点：索引块替换将导致对应的索引全部失效，但有锁Map一直有效。

二级索引的内存开销是Map索引的几十倍。

Map索引的代码好写程度是二级索引10倍。现阶段使用Map缓存块索引。

## 使用FAT缓存单元后的缓存块获取

### 访问第n个簇

1.  计算索引单元索引，有锁地将Weak指针upgrade为Arc，立刻释放锁。成功转3。

2.  upgrade返回了None，此时从索引单元管理器分配并更新，可能会释放某个索引。

3.  计算索引单元内索引，有锁地将对应Weak指针upgrade为Arc，立刻释放锁。成功转5。

4.  持有着索引单元Arc不释放，从全局缓存块分配器获取缓存块空间，更新索引单元。

5.  取走缓存块的Arc，潇洒地离开。


## FAT链表缓存块

将FAT链表扇区使用Weak指针索引，由全局FAT链表扇区管理器分配空间。

## 索引访问的LRU更新

### 通过索引访问的块不经过管理器，如何确保找到的缓存块是不被使用的？

寻找强引用计数为1的指针，使用try_unwrap()尝试取出缓存块，如果成功则修改缓存块信息，尝试删除旧的Weak，否则把失败返回的Arc则放回管理器。

### 如何找到“很有可能”是最后一次未使用的缓存块？

每个缓存块都维护了一个访问序列ID，使用Arc<AtomicUsize>.fetch_add无锁获取。

所有缓存块放置在Map<ID,Arc<cache>>的映射中，每次取出ID最小的项，判断ID和cache是否相等，如果不相等则放回对应时间的位置。

ID匹配后取出Arc并try_unwrap，如果失败了再获取一次ID并赋值（当前cache的ID可能还没被使用方更新），放入Map，成功则将此作为替换块。

此方法有小概率在判断ID相等后某进程从Weak获取Arc，更新时间，释放Arc一气呵成，然后本进程成功从Arc取出cache，但这种小概率事件发生了也仅仅是LRU违例降低效率，不会影响内核的安全。

### 如何防止还没有同步的缓存块被替换？

禁止替换脏标志位的缓存块。同步系统优先同步最后一次未使用的缓存块。

管理系统增加成员保存当前同步到的时间，同步系统从此时间开始搜索。

### 如何同步缓存块？

使用一种简单但有效解决饥饿的同步方法。维护两个集合S1和S2，S1是本次同步的集合，S2是下次同步的集合。

每个块脏标志改变时都会加入S2，而同步系统完成S1同步就会移动S2至S1，开始S1的同步。

# 缓存块同步系统

## 无阻塞写且磁盘太慢导致的缓存块不足

如果磁盘速度太慢，所有缓存块都含脏标志位，无法分配缓存块。

方法A：阻塞尝试分配缓存块的进程。

缓存块分配使用异步分配。当所有块都为脏或不在允许ID队列中时加入等待队列。

方法B：信号量阻塞正在疯狂写的进程，不让全部缓存块都是脏的。

缓存块共享一个信号量，尝试写入时需要先获取信号量，驱动完成缓存块写入时返还信号量。

信号量的值可以设置为内存的1%。

使用方法B。

## 数据结构

最大脏块数：允许的最大脏块数量

当前脏块数：如果小于这个数则不阻塞，并递增1。

## 信号量阻塞写入的操作顺序

1.  发起对缓存块的写入请求T，获取排他锁[await]。

2.  判断当前是否为脏状态，如果是则判断初始化，之后直接应用请求T，释放锁，结束。

3.  无脏标志。完成写入T，获取同步系统锁[await]+信号量[await]。

4.  修改脏标志，释放锁。


## 驱动中断驱动的同步系统操作顺序

中断处理程序不能完成

1.  驱动完成中断。

2.  获取同步系统自旋锁

3.  如果等待队列不为空则释放一个等待任务并更新相关标志，结束。

4.  如果等待队列为空则将脏块数减一，结束。


## 同步系统Future

自旋锁维护的包含：ID分配器，最大允许ID，等待队列，当前脏块数 最大脏块数

进入future：

判断是否首次进入：

首次进入则判断脏块数，成功则递增1，放行。不成功则阻塞，获取一个ID加入等待队列。

再次进入则判断ID是否不大于允许ID号，如果是则放行，否则阻塞。

## 释放信号量

释放信号量显然不需要阻塞，因此可以用在中断系统中。

获取同步系统锁，判断队列队列是否不为空：

如果不为空，则wake第一个任务，设置允许ID为此任务的ID。（保证ID递增）

如果不为空，则脏块数减一。

信号量由Guard保存，可以发送到同步任务中，任务结束了自动释放信号量。

# 使用上述全部优化后的文件系统总架构

## FAT链表相关

扇区缓存LRU管理器 最大使用2%系统内存。每项占用4.5KB的空间。

无竞争扇区缓存索引 占用空间为每扇区9B （8B指针+1B锁）

每个索引管理512B=128个簇号=512KB空间 需要空间1KB

1TB磁盘需要索引数组内存为18MB

FAT链表的修改全部通过管理器进行，因此管理器可以维护所有需要同步的扇区。

## 缓存块索引相关

缓存块索引LRU管理器 最大使用2%系统内存。每项占用4.5KB的空间。

无竞争缓存块索引的索引 9B每单元512个缓存块Weak索引（4KB+512B）

无竞争缓存块索引 9B每单元 =>4KB簇

1TB磁盘含256M个簇，需要512K个索引的索引 占用内存为4.5MB。

## 簇缓存相关

缓存块LRU管理器 最大使用10%系统内存。每缓存块占用4.5KB的空间。

包含指向inodeCache的Weak指针，只有FAT链表的首个簇的块缓存才有效。

共享-排他睡眠锁。

脏标志位。

基于共享COW缓存的无阻塞磁盘同步。

### 簇同步系统

所有脏标志的改变都需要先获取信号量。驱动写完成了需要回调。

设置初始化标志也需要获取信号量！

## inode相关

InodeCache LRU管理器，读写自旋锁，最大使用2%系统内存，每个InodeCache占用16KB。

InodeCache的索引放在FAT链表首个簇的缓存块上，缓存块/索引无效则从管理器中获取。

InodeCache内部缓存数据都由常规自旋锁保护。

懒加载的FAT链表缓存(读写自旋锁保护) -- inode引用计数为0也存在 8KB

缓存前1K个簇（占用4KB 对应磁盘空间16MB）

缓存每1K个簇的簇号，即1K 2K 3K..

缓存最后一个簇的簇号和它是第几个簇

禁止拿着缓存锁去获取磁盘FAT信息（磁盘FAT信息需要睡眠锁）

FAT链表读写-排他睡眠锁 改变FAT链表长度时必须获取排他锁

inode是文件打开的唯一标识，inodeCache是获取inode的唯一途径，inode不保存在任何的全局管理器中，这意味着InodeCache中的inode Weak指针无效即证明此文件没有被打开。打开inode的方法只有先从管理器获取inodeCache，再从inodeCache获取inode。

InodeCache持有根目录簇地址和对应InodeCache的Weak指针，所在目录项的偏移量，因此文件修改路径后需要修改或删除InodeCache。

Inode保存了此文件所属的目录对应InodeCache的Arc指针，防止根目录被删除/回收并方便地修改访问信息并防止文件打开时根目录被删除。

Arc<InodeCache>的持有者只有3个：

inode管理器、inode(进程打开的)、目录下级打开的文件的inode。

不能由打开的文件的InodeCache持有根目录的Arc指针，这会导致文件关闭后依然无法删除。

### 数据结构

管理器持有InodeCache的Arc。无进程时引用计数为1，由Arc::try_unwrap获取

进程持有的Inode的Arc。inode将在无进程时释放

Inode包含指向Inode的Weak。

Inode包含指向InodeCache的Arc。

首个簇包含指向InodeCache的Weak。

### 进程索引访问文件inode（文件/目录）

文件簇号是唯一标识，如果没有簇号，一个空文件根本没必要索引。

从目录项拿到簇号后：

通过索引尝试访问缓存块（获取缓存块不需要加载内容！）。

如果成功了尝试upgrade内部的inodeCache Weak指针。

如果上述操作失败了从inode管理器获取inodeCache的Arc指针。

尝试upgrade inodeCache中的raw_inode指针，如果失败了则创建一个新的raw_inode。

### inode缓存

保存最近一次读写非append读写的偏移量-簇号映射

## 空文件

如果某个文件是空的，FAT32此时簇号为0，那簇号不再能作为标识符了，如何处理多个进程打开空文件的情况？

解决方法A：没有簇号就给你簇号，打开空文件时强行分配一个簇，短文件名长度写入4096，写回时判断长度是否为0，如果为0就把这个簇释放了，并把文件长度改为真实长度。

移动文件后只需要改变父目录指针。

解决方法B：不使用CID作为标识符，而是使用短文件名地址(簇号,偏移)作为标识符。

需要保证打开的文件位置不会移动，移动文件时需要修改缓存管理器。

## RawInode

提供inode公共操作，使用睡眠锁保护。读和写使用同一个指针。

偏移量顺序读：共享锁 自带当前偏移量指针缓存

偏移量写：无锁获取当前长度判断是否在文件内 共享锁 二次判断 需要修改文件大小则为排他锁。偏移量不能大于文件大小，否则操作失败。（文件扩充要求）

末尾写：排他锁写 修改目录项 FAT链表

窗口读写：原子地将闭包以窗口方式访问块并进行相关读写。

## 目录inode

允许同时锁定多个缓存块，但绝不允许先锁定靠后的再锁定靠前的。

### 查找文件

获取inode共享锁 每个缓存块共享锁扫一遍即可

### 创建文件

获取inode共享锁找空位 缓存块使用排他锁 如果找不到则换成排他锁，分配新的空间后直接写入。

一次锁定相邻的两个块处理跨簇情况。

### 删除文件

获取inode共享锁查找，查到了则判断权限，在inode管理器中删除缓存。

只允许Arc::try_unwrap删除inode缓存。

可能同时锁定相邻的两个块，删除目录中的项，获取起始簇号，释放睡眠锁。

在FAT分配器中删除整条链表。

### 删除目录-强制

获取inode排他锁，不再允许其他进程访问此目录。

获取此目录缓存的引用计数。

使用模拟栈的方式深度优先地删除下层目录，只有要删除的目录为空时才能删除对应的目录。

### 文件位置移动 src => dst

不能乱序同时锁上两个移动的位置！否则分分钟死锁。

获取src的目录位置，持有一个Arc的inode引用。

inode共享锁检查src处文件是否存在，是否不被打开，记录所在偏移量，释放inode锁。

获取dst目录位置，持有一个Arc的inode引用。

按照CID从小到大的顺序给两个目录上inode排他锁。

根据记录的偏移找到src的名字项，在dst中分配一个位置，移动名字项。

在inode管理器中修改根目录簇地址和Weak指针项，如果缓存不存在则忽略。

如果是文件是目录，从簇地址直接获取对应缓存块把第一项的簇号与修改时间改了。无竞争保证：修改一个目录缓存块的唯一方式是通过inode或父目录，这个目录已经锁了。

释放两个锁，顺序任意，操作完成。

## 文件inode

非append操作：根据输入偏移量读写。

独立写：根据当前长度判断是否需要排他inode锁分配空间（只要文件变大了就要排他锁，即使不需要新的簇）。分配后改inode共享锁缓存排他锁写入即可。

独立读：使用inode共享锁和缓存块共享锁读取。

尾部写：忽略输入偏移量，使用排他inode锁，分配空间，修改长度，写入。

# 文件系统挂载

todo!() qwq

## 虚拟文件系统VFS

VFS提供了文件系统接口，操作系统对文件系统的操作从VFS进行。VFS挂载到某个目录下。





## 参考资料

# fat32文件系统

fat32 wiki: [https://wiki.osdev.org/FAT](https://wiki.osdev.org/FAT)

FAT32文件系统结构详解 [https://blog.csdn.net/li_wen01/article/details/79929730](https://blog.csdn.net/li_wen01/article/details/79929730)

FAT32长文件名短文件名目录项 [https://blog.csdn.net/u010650845/article/details/60780979](https://blog.csdn.net/u010650845/article/details/60780979)
