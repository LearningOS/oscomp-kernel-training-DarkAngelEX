# execve优化

## lazy execve

execve将文件加载到用户地址空间。显而易见，我们可以在程序执行的时候就将整个程序给全部加载，这样程序在执行的时候就可以达到最快的速度。

听起来非常美好，但很可惜，在execve时就将程序整体加载会大幅增加execve的时间，而其中一个基准测试就是测试execve的执行时间。这并不是execve影响性能的原因之一，还有一个原因，就是execve会映射大量的页面，而页面越多fork就越慢，即便采用了COW，一个页面也会产生缓慢的原子指令开销。如果我们按需加载页面，就可以显著降低execve的执行时间，还可以加快fork的速度。

我们已经实现了一个功能非常强大的映射管理器，它支持文件映射操作。我们可以直接利用和mmap相同的接口来映射execve分配的页，看起来非常的完美。

事实上确实非常完美，只有一个缺点，FTL OS是一个异步操作系统，而原来使用的`xmas_elf`库只能把整个文件加载后解析。如果我们把整个文件都加载了，那还做什么lazy execve？

`object`库是一个可以解析elf的库，相比`xmas_elf`，它不需要加载整个文件，只需要按需的读取文件的某个部分。听起来非常不错，但是FTL OS是一个异步操作系统，而`object`库的接口是同步的，无法接入FTL OS的文件系统。取巧的路都被封住了，因此FTL OS只能自己实现elf解析器。FTL OS将`xmas_elf`中使用到的逻辑用异步方式重新实现，接入操作系统后lazy execve可以正常的运行。

当接入lazy execve后，FTL OS的基准测试成绩提高了1分，与预想相差甚远。究其原因，在评分方式改变后，FTL OS的lazy execve仅仅接近了测试程序基准线，仍只拿着保底的1分。

## 地址空间复用

为了将优化贯彻到底，不再做拿着保底的非洲人，FTL OS决定面向测试程序进行优化，尽管这个优化在大多数情况下并不会生效。

比赛使用的lmbench是一个独立的，静态链接的测试程序。它是怎么测试execve的？它execve了lmbench，并使用"hello"参数。hello参数并不重要，重点是目标程序和源程序使用了同一个文件！在这种情况下，有没有办法可以复用页表呢？

操作系统完全把用户地址空间开放给了用户程序，用户程序可以通过mmap任意修改自己的映射。但这没关系，操作系统可以记录对地址空间的操作，并抛弃那些改变了的页面。哪些页面是不应该抛弃的？所有没有写权限的初始页面都不需要抛弃。

如果更进一步，FTL OS可以记录是否原始映射发生了变化。如果原始映射没有变化，那么说明映射管理器里保留的文件映射都是有效的。那么就完全不需要去文件系统加载数据了，因为映射管理器已经全部处理好了。我们只要释放全部的非初始页面与可写页面，保留它的handler，然后像普通程序一样加载其他东西即可。

FTL OS首次采用地址空间复用方式时直接保留了上次执行留下的初始化mmap句柄。一通操作猛如虎，测试程序在`__libc_start_main`就因为访存页错误报错了！但在execve执行的时候，lmbench在报错地址的映射是具有写权限的。很快我们就发现，libc在初始化的时候会通过`mprotect`系统调用去除写权限，于是保留句柄的方式就不能使用了。

这个问题很容易解决。我们可以让复用标志位在权限改变的时候就删除，这样就不会有残余物留在那儿了。不过这样也会导致在该映射的地方留下了空位，我们必须把空位给填上。FTL OS采用的方式是增加一个`replace_no_release`接口，从程序文件中读取要加载的段后直接覆盖原来的句柄，同时复用原来页表中的数据。

此优化让fork+execve基准测试耗时从2200us降低到890us，效果非常明显，最重要的是，FTL OS不再拿着保底分了。

