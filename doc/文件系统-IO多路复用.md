# IO多路复用

在支持imbench的过程中需要实现ppoll和pselect6系统调用，这两个系统调用用来在Linux上实现IO多路复用。IO多路复用模型可以让一个服务线程同时管理多个多个网络端口，让服务器在超大并发时不再需要开启大量的线程，降低系统资源开销。

Linux平台和Windows平台有各自的IO多路复用模型，分别对应Reactor模型和Proactor模型，这两种模型分别有各自的运行方式。

## Reactor模型

reactor的本意是反应堆，它的处理是基于事件的。一个典型的Reactor模型是这样处理的：处理线程会监听事件，这个监听过程是由内核完成的。当事件没有到达的时候，线程会阻塞在系统调用里；事件到达之后，线程就会进入用户态进行相关处理。每种事件都有各自的类型，不同的线程可以监听不同的事件，让不同的线程各司其职。reactor就是监听事件的线程，它收到事件后可以立刻进行处理，也可以分发到其他的线程，专注于监听操作。

## Proactor模型

Proactor模型和Reactor模型不同。Reactor模型的事件是由用户处理的，reactor只负责监听事件，分发事件后该事件还需要由对应的线程处理。但Proactor模型中事件是由操作系统处理的，而操作系统处理完成后才会通知线程，这个处理的过程包括把数据复制到用户地址空间。

## 系统调用

Reactor模型依赖的内核实现非常简单，只需要内核将线程阻塞在内核态，等待具体操作完成即可。

### ppoll

| struct pollfd* | nfds_t     | const struct timespec* | const sigset_t* |
| -------------- | ---------- | ---------------------- | --------------- |
| 监听文件数组   | 数组的长度 | timeout 指针           | 信号掩码        |

监听文件数组的每个单元是(文件号, events, revents)的64位三元组。如果文件号为负数则被忽略，并设置revents为0。

events是16位的bitset。它包含如下的选项：

* POLLIN 存在可以读取的数据
* POLLPRI 存在异常
* POLLOUT 存在可以写入的空间
* POLLERR 只存在于revents，读端已经关闭
* POLLHUP 只存在于revents，channel对等端关闭
* POLLNVAL 只存在于revents，例如fd没有打开

timeout使用的是相对时间，设为负数意味着timeout为无穷大，而设为0意味着立刻返回。

如果信号掩码指针不为NULL，则等价于原子地在等待期间修改当前线程的信号掩码为对应值，并执行poll，而结束后再恢复信号掩码的旧值。

ppoll执行成功的返回值是数组中revents不为0的个数。

数组的长度限制为RLIMIT_NOFILE，它是进程能打开的最大文件数量。

如果在进入系统调用之前已经存在信号将返回EINTR。

### pselect6

| int      | fd_set*  | fd_set*  | fd_set*  | const struct timespec* | const sigset_t* |
| -------- | -------- | -------- | -------- | ---------------------- | --------------- |
| 文件数量 | 读取集合 | 写入集合 | 异常集合 | timeout 指针           | 信号掩码        |

文件集合的长度不能超过1024。已经准备好的文件对应的位会被留下，其他的值都将清零。

如果执行成功，返回poll成功的文件数量，超时时返回的数量可能是0。

任何文件描述符不存在都会导致系统调用失败。

如果在进入系统调用之前已经存在信号将返回EINTR。

## 实现

FTL OS这一项的基准程序分数显著低于其他队伍，约产生了3倍的开销。这并不是FTL OS太菜了，而是其他队伍的等待全部采用yield实现，在测试程序中可以获得很好的表现。FTL OS不想同流合污，实现了线程安全的，支持睡眠的IO多路复用方案。

当线程阻塞在pselect6后，如何让它可以被任何的文件唤醒？FTL OS的唤醒通过waker实现，因此我们需要让每个文件都能拿到待唤醒的任务的waker。但waker是通过Arc实现的，而Arc的复制采用了开销极大的原子操作。为了绕过这个限制，FTL OS决定只保留一个所有权waker，并在其他文件上放置指向waker的指针。如果采用了这个方案，当线程被唤醒后，它必须主动撤销放置在其他文件上的等待器，否则waker将变成野指针。

还有一个问题，如果多个线程阻塞在了同一个文件怎么办？文件必须能够放置多个waker，并保留必要的信息。采用什么数据结构来管理呢？侵入式链表是唯一能同时支持O(1)的局部插入删除的数据结构，因此FTL OS在每个文件上都放置了一个侵入式链表头节点，每个阻塞在这个文件上的线程都会持有一个等待器，并把等待器连接到链表上。

ppoll包含三种事件，如果我们用一条链表来管理三种事件，那么对任何一种事件的唤醒都必须遍历整条链表，开销极大。因此我们用三条链表来分别管理三种事件，任意事件的唤醒只需要遍历它所在的链表。任何等待器都包含了三个链表节点，但只有设置了事件的链表才会真正地加入文件上的链表。

等待器怎样才能知道自己被唤醒了呢？等待器上包含一个revent成员，这个成员初始化为0，并只有文件才有权限修改。如果文件唤醒了这个等待器，那么会先将revent中写入对应的事件。当future执行时，它一旦检测到某个文件的revent不为0就会从阻塞状态退出，并撤销全部的等待器。注意，等待器的撤销只能在析构函数中进行，因为future并不保证会正常结束，它完全可能被提前撤销，只有析构函数是正常情况下保证执行的，析构函数未执行也只会导致内存泄露而不是野指针。