# 页表映射

Hifive Unmatched开发板文档上支持ASID，但实际测试中ASID无效，因此切换页表后必须要刷表。hifive开发板相比K210在硬件上支持sfence.vma指令，不需要sbi代理，因此sfence.vma执行只需要刷新处理器流水线(约10时钟)。尽管如此开销大幅下降，但TLB未命中带来的开销依然较大。

FTL OS的页表同时映射了用户段和内核段，在用户态和内核态切换时不切换页表，只有在进程切换或修改页表时才需要刷表指令。

Hifive Unmatched开发板支持16 GB的内存，而内核入口地址为0x80200000。如果将0x80000000作为用户数据和内核数据的分界线，用户虚拟地址将只能获得2 GB的空间，单个进程无法充分利用16 GB的内存。为了充分使用硬件资源，FTL OS将内核段划分至0xffff_ffc0_0000_0000 - MAX，用户段划分至0x0 - 0x40_0000_0000，用户段和内核段都拥有256GB的空间，可以进行更进一步的划分。

## 进入内核

内核段重新映射后不可以从入口地址(0x80200000)直接call/j跳入内核入口函数，因为编译器的链接基址为0xffffffff80200000，在编译器看来运行在这里时PC=0xffffffff80200000，但实际上PC=0x80200000！能够正常运行仅仅是因为两个地址对齐了而已。普通的跳转方式使用auipc进行相对地址跳转，而从0x80200000地址相对跳转只能进入虚空。因此必须先将内核地址映射到高位地址，切换页表后再通过jr跳转至内核入口。

如何在entry函数中完成完整的高位内核映射？用汇编写一个页表映射函数？事实上sv39不仅支持4 KB的页映射，还支持2 MB和1 GB的巨页表映射。利用巨页表即可方便地将物理地址映射到高位地址空间：

```assembly
	# kernel/src/hart/boot/entry64.asm
	.align 12   # page align
boot_page_table_sv39:
    # 0x00000000_80000000 -> 0x80000000 (1G) 2 physical mapping
    # 0xfffffff0_80000000 -> 0x80000000 (1G) 450 kernel direct mapping offset
    # 0xffffffff_80000000 -> 0x80000000 (1G) 510 kernel link
    # -2- <2> -447- <450> -59- <510> -1
    .quad 0
    .quad 0
    .quad (0x80000 << 10) | 0xcf # VRWXAD
    .zero 8 * 447
    .quad (0x80000 << 10) | 0xcf # VRWXAD
    .zero 8 * 59
    .quad (0x80000 << 10) | 0xcf # VRWXAD
    .quad 0
```

boot页表在映射了高位地址的同时还保持了物理地址的直接映射，利用它就可以正常进入内核入口函数rust_main了。显然这个页表的映射太过于暴力，因此需要在内存初始化中替代为更加精细的页表。虚拟地址映射如下：

## 虚拟地址

sv39支持39位地址空间，寻址时高25位需要和第39位相同，否则将产生页错误。利用高位0/1划分为用户区和内存区，两个区域的地址空间都是256 GB，根本用不完。

### 内核段

| 描述                      | 起始地址              | 结束地址              |
| ------------------------- | :-------------------- | --------------------- |
| 全部映射(256 GB)          | 0xffff_ffc0_0000_0000 | MAX                   |
| 硬件IO地址(1 GB 未使用)   | 0xffff_ffff_c000_0000 | 0xffff_ffff_ffff_f000 |
| 内核数据段(1 GB)          | 0xffff_ffff_8000_0000 | 0xffff_ffff_c000_0000 |
| 直接内存映射(32 GB)       | 0xffff_fff0_0000_0000 | 0xffff_fff8_0000_0000 |
| 文件映射 (64 GB 未使用)   | 0xffff_ffd0_0000_0000 | 0xffff_ffe0_0000_0000 |
| 虚拟内存映射(64GB 未使用) | 0xffff_ffc0_0000_0000 | 0xffff_ffd0_0000_0000 |

### 用户段

| 描述              | 起始地址       | 结束地址       |
| ----------------- | -------------- | -------------- |
| 全部映射(256 GB)  | 0x0            | 0x40_0000_0000 |
| 链接基地址        | 0x10000        | 0x10000        |
| 数据段(32 GB)     | 0x10000        | 0x8_0000_0000  |
| 堆段(32 GB)       | 0x8_0000_0000  | 0x10_0000_0000 |
| 线程栈段 (64 GB)  | 0x10_0000_0000 | 0x20_0000_0000 |
| 文件映射 (128 GB) | 0x20_0000_0000 | 0x40_0000_0000 |