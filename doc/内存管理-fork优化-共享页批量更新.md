# 共享页的原子计数批量更新

fork的开销主要在3部分，分别是帧分配，帧初始化，共享计数的原子操作。FTL OS的帧分配已经采用了批量分配优化，只需要获取一次锁就分配大量的帧，将锁开销给分摊了。目录页表缓冲区彻底删除了帧的初始化过程，因此fork里开销最大的部分就变成了原子计数的操作，它的开销达到了其他两项之和的6倍。

在[RCU智能指针](./内存管理-RCU智能指针)中讨论了一种不需要原子操作就能完成的引用计数内存管理方案。这个方案并没有被FTL OS采用，因为它需要内核为专门设立一个和RCU类似的复杂同步系统，而它的使用场景太过单一。为什么RCU智能指针这么复杂？因为智能指针的用途非常广泛，它可能会被使用在各种各样的场景，必须保证所有场景的正确性。但是页表内存不一样，它的使用场景非常单一，具有极强的可控性。我们可以针对它的可控性设计一个更简单的内存回收方案，在不泄露内存的情况下降低原子开销。

FTL OS的方案是让共享页的引用计数用统一的管理系统运行，并保证引用计数递增与递减的有序性。我们希望引用计数满足这样的约束：

* 当观测到引用计数是1时，它一定持有着唯一的所有权。
* 每个引用计数都具有所有权，每个递减操作都对应着唯一的递增操作。
* 当引用计数递减操作被提交时，对应引用计数递增操作必须处理完毕。
* 只有持有引用计数所有权才可以操作引用计数。
* 引用计数的操作不必是原子的。

只要满足这个要求，当管理系统或引用计数操作者者观测到引用计数为1时就可以立刻获取此内存的所有权。FTL OS采用的RCU系统无法满足这个要求，因为性能原因，多核之间的RCU释放顺序是没有约束的，引用计数的递减操作完全可以在递增操作之前执行。FTL OS需要另外设置一套支持多核有序操作的管理系统。

FTL OS认为共享页的管理如下：

* 所有权的页fork成两个共享页。直接设置引用计数为2，不需要经过引用计数管理器。
* 共享页fork获取新的共享页。如果引用计数为1则直接生成新的共享页，否则将更新操作保存到集合中，fork结束时一次性提交给管理系统。
* 共享页修改权限或释放。如果引用计数为1则直接释放，否则将递减操作提交给引用计数管理器。此操作可以任意延迟。
* 在共享页的引用计数递增操作提交之前，新的引用计数所有权不能被操作。
* 一次只能有一个核运行管理系统，管理系统会操作引用计数，当管理系统观测到引用计数为1时释放共享页。

共享页的释放可以任意延迟，而且没有太大的限制。我们可以在时钟中断中或IDLE状态中操作管理系统，将对快速路径的影响降低到最低。单核运行的条件非常简单，只需要用自旋锁保护并用try_lock获取锁即可。try_lock获取锁失败时可以直接放弃操作，因为内存释放的延迟不会影响操作系统的安全性。

## 共享页管理的数据结构

幸运的是，上述方案可以直接融合进FTL OS原本的共享页管理系统中，不需要改变数据布局，只需要略微修改对原子计数的操作。FTL OS使用了如下的数据结构来管理共享页：

```rust
/// 包含原子计数的共享内存
struct SharedBuffer(AtomicUsize);
/// 计数器共享所有权句柄, 只能手动释放
pub struct SharedCounter(NonNull<SharedBuffer>);
```

在原方案中，每个`SharedCounter`都持有`SharedBuffer`的所有权。共享页管理器会使用`SharedCounter`来操作`SharedBuffer`的原子计数，处理了一切可能的场景，保证在任意情况下都不会出现内存泄露。共享页管理器通过`try_remove_unique`和`remove_ua`两个接口来保证这一点，第一个接口用来提高系统性能，用来直接获取引用计数为1的页的所有权。第二个接口用来兜底处理，它在任何情况下都会递减引用计数，并返回自己的引用计数是不是1。需要注意，即使第一个接口操作失败了，第二个接口依然可能返回引用计数为1，因为引用计数可能已经被另一个核给递减了，并且由于多核可见性问题没有被第一个接口观测到。

新的方案里，我们依然可以复用这一套逻辑。第一个接口依然可以复用，我们只需要处理第二个接口，将它从原子递减修改为提交给缓冲队列。当全部操作结束后再将它提交给管理系统。

管理系统的回收还能进一步提高性能。FTL OS的帧分配器提供了批量回收接口，因此管理系统可以将需要回收的帧暂存，全部扫描一遍并获取了需要回收的帧后再通过批量回收接口以最高吞吐量回收全部的帧。在获取帧分配器锁之前可以提前释放管理系统的锁。

引用计数的递减尽管延迟任意长的时间都能保证正确性，但它会在事实上降低性能，因为有些事实上引用计数为1的页可能在数值上仍然为其他值，必须等待管理系统处理引用计数申请后才能观测到。如果管理系统太久没有运行，那么这些页只能使用缓慢的复制来创建一个所有权页，因此共享页的释放申请越早越好。但如果我们每次修改共享页都提交申请，那么必须频繁地获取管理系统锁，这会增大系统开销。

那么什么时候提交引用计数递增申请，什么时候提交引用计数递减申请呢？为了让系统的效率尽可能地高，我们首先要明确各种场合下的场景。引用计数的修改大致可以分为四种情况：

* 批量地增加引用计数。在fork时发生。
* 批量地递减引用计数。在unmap或进程退出时发生。
* 单次地增加引用计数。可能在缺页异常时发生。
* 单次地递减引用计数。在COW缺页异常时发生。

加速前两种情况非常简单，只需要操作时缓存所有引用计数修改申请，操作结束时把引用计数修改提交即可。为了提高速度，unmap执行之前应该主动地处理管理系统，调整引用计数。

后两种情况在FTL OS应用了普遍的lazy-execve和COW后非常频繁，但降低它的开销并不简单。我们可以使用per-CPU缓冲区来缓存它的修改，并在上下文切换或时钟中断发生时主动将缓冲区刷入管理系统。这在单线程进程里可以保证递增和递减是严格有序的，但在多线程环境下就不一样了。FTL OS认为我们可以用更简单的方法，就是将缓冲区放在进程控制块中。因为当我们要操作页表时必须要获取进程控制块的锁，这就掩盖了缓存区的锁开销，还不会违反引用计数有序约束。

为了防止本进程积累太多的未提交页面，我们可以强制要求当缓存数量达到某个值时提交给全局管理器。这个值越大就能分摊越多的锁开销，但也会导致在另一个线程产生更多的复制开销。

## 全局管理器应该干什么？

全局管理器负责修改引用计数。但是在不需要原子操作的情况下，修改引用计数是一个只有两次访存的高速操作，它的开销甚至比“提交申请”这一操作还要小。在这个状况下全局管理器反而成为了最大开销来源。

如果用链表实现全局管理器，确实可以大幅降低提交申请的开销，但它相比于数组会产生大量的cache-miss，这部分开销会体现在分配与释放上。从经验来看，链表的全局性能通常会比数组低得多。

全局管理器带来了什么？它提供了一个单线程的环境来释放引用计数。如果我们让全局管理器只保留一个锁，然后让每个进程按序释放自身的引用计数，是不是就可以绕过庞大的开销了？这个方案的本质是每个引用计数都持有了同一个锁，看起来会降低并行度。但引用计数的吞吐量实在太低，新的方案本质是将引用计数的操作批量处理，同时用少量的锁开销将引用计数操作串行化来获得最高的吞吐量。这和垃圾回收很像，但我们只需要处理要改变的对象，而不是和垃圾回收一样扫描全局空间的每一个对象，因此不会产生STW现象。

在这个方案下，各种对引用计数从操作实现如下：

* 批量引用计数操作。执行前强制提交进程缓存的全部申请，然后缓存所有的引用计数修改，操作结束时获取全局管理器锁修改引用计数。

* 缺页异常。引用计数修改提交到本进程缓冲区，当缓存数量达到预设值时获取管理器锁更新引用计数。这个刷新过程可以使用try_lock进行，因为它的存在仅仅是为了降低其他进程的开销，不会影响系统的安全性。

这个方案只需要对系统作极少量的修改，我们只需要增加一个全局有效的锁即可。

## 结果

喜闻乐见，此“优化”成功降低了fork的20%性能，耗时从330us增加到413us，总分降低了0.8，被迫回退400行代码（依然保留提交记录，以后可能还要用）。原因可能是引用计数的开销并不像想象中的那么严重，附加设施反而导致了更多的cache-miss。此优化还导致了测试程序中每轮fork都产生两次可以避免的COW复制，原因是页面的引用计数没有尽早更新。

