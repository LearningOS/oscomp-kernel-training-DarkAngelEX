# FTL OS系统框架

FTL OS是深度融合rust async逻辑的异步架构操作系统。rust async采用无栈协程，这意味着上下文切换时不需要切换正在运行的栈，整个系统完全运行在入口的栈上。rust在debug模式下栈开销远大于4KB的，而栈需要连续的内存，分配巨大的连续空间会增加压力，或将开销转移到页表分配上。而无栈协程中栈的数量就是核心数量，可以直接写死在入口函数里。

FTL OS 异步核心为 async-task。这个库保证了协程在任意时刻被多次唤醒的正确性，不用担心协程唤醒丢失或运行完成前被二次加入调度器。

FTL OS在内核页表使用共享映射，这也意味这FTL OS不能将每一个进程的栈映射到同一个地址，不能使用虚拟地址方式支持大于32KB的内核栈。为了支持新SOC的16GB内存，由于16GB已经大于32字节寻址空间，FTL OS将内核区域放置于高位地址，用户区域放置于低位地址，在高位地址划分偏移量基准的直接内存映射，用来直接访问物理地址，用户占有地位地址256GB的全部空间。

为了降低刷新页表导致的1000时钟周期的开销，FTL OS利用了satp寄存器的asid位，将刷表局限于exec于页错误处理，将页表切换速度提高了50倍。

rCore指导书内存分配器采用了外部库的buddy分配器。查阅源码得知此分配器的dealloc函数寻找伙伴时采用时间复杂度O(N)的遍历查找，这意味着释放N个不连续内存时间复杂度是O(N^2)!!!实在太过于愚蠢。FTL OS重新编写了buddy分配器，将dealloc函数修改为链长达上次释放后的两倍才触发回收，回收使用时间复杂度O(N log N)的归并排序，如此平均释放时间复杂度降低到O(log N)。与此同时，FTL OS在每个核心放置了独立无锁的内存分配缓存，当缓存空或满时一次性读写全局分配器。缓存链表包含有一个指向链表尾的指针，如此便可以支持O(1)复杂度链表合并，将全局分配器读写的时间复杂度降低到O(1)。以上优化后内存分配器性能提高了5倍以上。

经过benchmark得知qemu平台锁开销是普通指令的30倍，而修改csr寄存器开销是原子指令的3倍。为了移除不必要的中断开关，FTL OS以栈方式控制中断，只有中断状态改变时修改CSR寄存器。

FTL OS采用异常方式测试用户指针，在划定区域内触发全部错误并捕获。使用向量方式分离异常和中断的陷阱函数，使暂时改变异常陷阱时不需要关中断。

为了继续提高性能，FTL OS引入了无锁数据结构，无锁数据结构除了不需要锁外还不需要关中断。

FTL OS保证上下文只在await处被切换，同时自旋锁被标记为!Send。这意味着能够通过编译的FTL OS不会处于阻塞态时切换上下文，保证CPU不会长时间无意义空转。标记了Send的锁为睡眠锁，线程等待睡眠锁时会加入等待队列让出CPU。