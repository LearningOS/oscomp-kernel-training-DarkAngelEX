# 无栈协程

说到无栈协程，首先要说明什么是协程。协程是在用户态模拟多线程的一种方式，区别是上下文没有操作系统的介入，上下文切换完全在用户态进行。协程调度器就像在用户态运行一个轻量操作系统，管理一系列协程的运行。但协程不同于线程，协程是用户程序的一部分，完全由开发者控制，因此不像操作系统一样需要抢占式调度，而可以使用更高效的协作式调度，在固定的调度点进行上下文切换。

协程作为一个可以调度的对象允许函数在还没有完成之前离开当前的上下文，并在未来恢复并继续执行。离开一个函数只有两种方式：调用一个新函数与退出当前的函数，有栈协程和无栈协程分别对应了两种离开当前函数的方式。有栈协程的切换如下：

![image-20220527211023880](D:\University\OS competition\ftl-os\doc\pic\无栈协程-有栈切换.png)

有栈协程的切换非常简单，因为调用一个函数不会销毁栈上数据，因此只需要保存现场并切换至待调度上下文即可。对于RISC-V，上下文切换需要改变s0-s11、ra、sp共14个寄存器，其他的临时寄存器不需要保存。上下文切换函数与其他函数对语言来说没有本质区别，因此有栈协程的切换函数可以插入至程序的任意位置，因此一段普通程序改写成有栈协程是非常简单的。有栈协程的缺点很明显，每个上下文都需要分配独立的栈空间，而函数的调用深度是无法确定的，因此很容易出现栈空间溢出或浪费空间的情况。另一个问题是上下文切换修改了函数调用栈，因此CPU内部的函数调用缓存全部失效，每次函数返回都导致一次分支预测失败，对流水线较长的高性能CPU性能开销非常大。

无栈协程通过函数返回的方式离开当前函数的上下文。无栈协程的切换如下：

![image-20220527211750325](D:\University\OS competition\ftl-os\doc\pic\无栈协程-无栈切换.png)

`func A`切换上下文时会依次退出函数直到回到调度器，但数据依然保存在堆上。调度器执行另一个函数时根据堆上信息重新生成了调用栈，恢复执行`func F`。

`rust`是如何编译`async`函数的呢？对于一个`async`函数：

```rust
async fn function() {
    async_fn().await;
    async_fn().await;
}
```

rust编译器将function编译成如下的状态机：

```rust
enum Status {
    S0, S1, S2,
}
fn async_fn_poll() -> Poll<()> {
    todo!()
}
fn function_poll(mut s: Status) -> Poll<()> {
    loop {
        match s {
            Status::S0 => match async_fn_impl() {
                Poll::Ready(()) => s = Status::S1,
                Poll::Pending => return Poll::Pending,
            },
            Status::S1 => match async_fn_impl() {
                Poll::Ready(()) => s = Status::S2,
                Poll::Pending => return Poll::Pending,
            },
            Status::S2 => return Poll::Ready(()),
        }
    }
}
```

以上函数忽略了一些细节，例如`async_fn_poll`的状态需要从`function_poll`自身获取。但可以看到，`async_fn_poll`的上下文返回的过程就是普通的函数返回，不需要进行栈的切换，不需要改变栈寄存器，CPU的函数调用缓存可以正常工作。无栈协程的切换速度远高于有栈协程，速度甚至可以达到4倍以上。

无栈协程的另一个优点是作用域跨越`await`的变量将分配在函数自身所属的结构体上，而结构体的大小是在编译时就确定的。因此在编译的时候我们就可以获知整个异步任务需要的空间大小，一次性在堆上分配，完全不需要担心栈溢出的问题。与此同时，无栈任务运行在同一个栈上，因此栈的数量就等于线程数量或CPU的数量。如此少的栈意味着可以给他们开出巨大无比的空间，不再需要担心非溢出下的栈溢出的问题。
