# 无栈协程

说到无栈协程，首先要说明什么是协程。协程是在用户态模拟多线程的一种方式，区别是上下文没有操作系统的介入，上下文切换完全在用户态进行。协程调度器就像在用户态运行一个轻量操作系统，管理一系列协程的运行。但协程不同于线程，协程是用户程序的一部分，完全由开发者控制，因此不像操作系统一样需要抢占式调度，而可以使用更高效的协作式调度，在固定的调度点进行上下文切换。

有栈协程和无栈协程的区别就在于上下文切换的方式。有栈协程的切换非常简单，只需要将当前的寄存器组保存并切换至待调度上下文即可。对于riscv，上下文切换需要改变s0-s11、ra、sp，共14个寄存器，其他的临时寄存器不需要保存。有栈协程的切换函数可以插入至程序的任意位置，因此一段普通程序改写成有栈协程是非常简单的。有栈协程的缺点很明显，每个上下文都需要分配独立的栈空间，而函数的调用深度是无法确定的，因此很容易出现栈空间溢出或浪费空间的情况。

无栈协程和有栈协程在上下文切换上有本质区别。举个例子：

```rust
async fn function() {
    async_fn().await;
    async_fn().await;
}
```

rust编译器将function编译成如下的状态机：

```rust
enum Status {
    S0, S1, S2,
}
fn async_fn_impl() -> Poll<()> {
    todo!()
}
fn function_impl(mut s: Status) -> Poll<()> {
    loop {
        match s {
            Status::S0 => match async_fn_impl() {
                Poll::Ready(()) => s = Status::S1,
                Poll::Pending => return Poll::Pending,
            },
            Status::S1 => match async_fn_impl() {
                Poll::Ready(()) => s = Status::S2,
                Poll::Pending => return Poll::Pending,
            },
            Status::S2 => return Poll::Ready(()),
        }
    }
}
```

以上函数忽略了一些细节，例如async_fn_impl的状态需要从function_impl自身获取。但可以看到，从async_fn_impl的上下文返回的过程中不需要进行栈的切换，也没有必要改变大量的寄存器。需要注意的是无栈上下文切换效率和调用深度有关，当深度很大时效率反而会低于有栈上下文切换。通常情况下无栈协程的切换速度远高于有栈协程，速度甚至可以达到4倍以上。

无栈协程的另一个优点是作用域跨越await的变量将分配在函数自身所属的结构体上，而结构体的大小是在编译时就确定的。因此在编译的时候我们就可以获知整个异步任务需要的空间大小，一次性在堆上分配，完全不需要担心栈溢出的问题。与此同时，无栈任务运行在同一个栈上，因此栈的数量就等于线程数量或CPU的数量。如此少的栈意味着可以给他们开出巨大无比的空间，不再需要担心非溢出下的栈溢出的问题。
