# 浮点与优化

参考华科xv6-k210可以正常运行浮点指令。

具体要做的：

在mstatus中开启浮点单元。

设置sstatus中的浮点标志位为FS::Initial / FS::Clean.

正常保存寄存器。

注意多核下每个核都要启用浮点。

# 浮点寄存器保存优化

浮点寄存器有32个，保存开销很大。如何减少保存的数量？

启用浮点后sstatus标志位中含有三种可能：init, clean, dirty.用户调用浮点运算时标志位会变为dirty。

保证操作系统内核态不使用浮点运算。

我们希望：

上下文未切换时，不保存浮点寄存器。

上下文切换时，浮点寄存器只保存第一次。

不进入用户态时，不加载浮点寄存器。



这需要对fs位进行操作：

约定内核态绝不出现dirty，退出用户态时清空dirty标志。

首次进入时设置为dirty，强制第一次上下文切换保存寄存器。

在上下文切换点判断fs标志。为dirty时保存浮点寄存器，保存后设置为clean。

在进入用户态时判断是否发生上下文切换。如果发生则加载寄存器。



频繁读取csr寄存器开销不小，考虑增加两个标志位，need_load与need_store。

need_load在上下文切换时设置为1，need_store在dirty时设置为1。

上下文切换前判断need_store位，如果为1则保存浮点寄存器，need_store置0。

进入用户态时判断need_load位，如果为1则加载浮点寄存器。need_store置0。

进入用户态时设置clean标志位。

此方法可以在离开用户态后不再关系sstatus，将状态保存至内存中。

此方法延迟了浮点寄存器的保存，需要确保内核不使用浮点运算。

确保上述方法的方式是只在浮点数上下文相关函数使用#[target_feature(enable = "d")]来局部启用浮点指令集，而不在全局使用浮点指令集。