# 内存分配器

常见内核都使用buddy伙伴内存分配器，它以2幂划分空闲内存至各个集合，分配内存时从对应大小的集合取出一块，如果不能取出则从上级集合分裂出对应大小的内存。释放时放回对应的集合，并判断集合中是否存在可以合并的另一块内存，如果存在则合并这两块空间，加入合并后对应的集合。

rCore-tutorial采用了第三方库的buddy_system_allocator分配器作为全局的堆分配器。此分配器使用链表管理同大小的集合，默认分配器内部的内存块不存在其他的引用，直接在每个内存块头部保存一个指针，利用此指针将各个内存连成链表，为了保存指针，最小的可分配空间为8字节。buddy_system_allocator释放内存的合并策略是扫描整条链表寻找伙伴，因此每次释放操作的时间复杂度是O(N)，内存碎片越多性能越低。

TCmalloc是google开发的高速内存分配器，使用线程缓存技术在每个线程放置了内存分配缓存，从分配缓存中分配内存不需要获取锁。

## FTL OS内存分配器实现

FTL OS希望构造一个高速的内存分配系统，希望兼顾性能和安全时尽可能简单。

管理内存需要建立内存页之间的数据结构，数据结构信息有三种放置方式：

* 被管理的内存内部（buddy_system_allocator方式）
* 被管理的内存之前（C++ new方式）
* 使用另外的内存分配器分配

第二种方式是绝大多数内存分配器的管理方式，这种用户不小心向被释放的内存写入数据也可以基本保证数据结构不被破坏。但如果内存是利用伙伴分配器分配的，这种方式会导致极大的实际空间开销，例如内存页要求对齐至4 KB，为了额外放置元信息的空间，伙伴分配器不得不分配8 KB的空间，空间直接损耗了50%！

FTL OS相信rust的内存安全性，永远相信不会使用被释放后的内存，因此使用了将信息放在被管理内存内部的方式。

FTL OS使用了TCmalloc的线程局部分配器优化，CPU内部都拥有分配缓冲区，cache空时继续分配则从全局分配器调入内存，cache满时释放一半内存。局部分配器分配内存时不关中断，当发生中断嵌套使用时自动切换为全局分配器。

## 内存释放优化

buddy_system_allocator内存释放的时间复杂度太高了，是否有更高效的实现方法？

### 定期回收策略

每次释放内存都O(N)搜索太慢了，可以修改定期回收策略。对每个链表，设上一次回收后的长度为N，取一合适的k值（如2），当释放内存使链表长度到达kN且kN大于某个常数C时进行回收。合并段的方式为先整体排序，临时调入最大长度的连续内存，将整个链表写入这个段后使用随机访问的快速排序，合并完成后写回链表。如果连续内存空间不足可以使用链表上的快速排序，性能相对随机访存的快速排序会明显下降。回收的时间复杂度是排序的O(NlogN)，平均复杂的降低至O(logN)。分配内存的复杂度为O(1)，且不会在大量重复分配释放时出现大量拆分合并，这是FTL OS目前采用的优化策略。

### 使用更快的容器

可以使用时间复杂度更低的容器来替换缓慢的链表。树状数据结构会将释放内存的复杂度降低至O(logN)，但也将申请内存的时间复杂度提高至O(logN)。集合的节点需要使用其他动态分配的方式，这会产生更低的内存开销。
