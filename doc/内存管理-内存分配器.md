# 内存分配器

常见内核都使用buddy伙伴内存分配器，它以2幂划分空闲内存至各个集合，分配内存时从对应大小的集合取出一块，如果不能取出则从上级集合分裂出对应大小的内存。释放时放回对应的集合，并判断集合中是否存在可以合并的另一块内存，如果存在则合并这两块空间，加入合并后对应的集合。

rCore-tutorial采用了第三方库的buddy_system_allocator分配器作为全局的堆分配器。此分配器使用链表管理同大小的集合，默认分配器内部的内存块不存在其他的引用，直接在每个内存块头部保存一个指针，利用此指针将各个内存连成链表，为了保存指针，最小的可分配空间为8字节。buddy_system_allocator释放内存的合并策略是扫描整条链表寻找伙伴，因此每次释放操作的时间复杂度是O(N)，内存碎片越多性能越低。

TCmalloc是google开发的高速内存分配器，使用线程缓存技术在每个线程放置了内存分配缓存，从分配缓存中分配内存不需要获取锁。

## FTL OS内存分配器实现

FTL OS希望构造一个高速的内存分配系统，希望兼顾性能和安全时尽可能简单。

管理内存需要建立内存页之间的数据结构，数据结构信息有三种放置方式：

* 被管理的内存内部（buddy_system_allocator方式）
* 被管理的内存之前（libc malloc方式）
* 放置于其他内存块

第二种方式可以一次性分配元数据与载体，且用户不小心向被释放的内存写入数据时也可以基本保证数据结构不被破坏。但如果内存是利用伙伴分配器分配的，这种方式会导致极大的实际空间开销，例如内存页要求对齐至4 KB，为了额外放置元信息的空间，伙伴分配器不得不分配8 KB的空间，空间直接损耗了50%！

FTL OS相信rust的内存安全性，永远相信不会使用被释放后的内存，因此使用了将信息放在被管理内存内部的方式。rust的内存分配与释放也和C/C++不同，绝大多数内存都通过Box智能指针分配，可以从类型获取内存释放信息，编译器将自动向分配函数与释放函数中填入分配信息。

FTL OS使用了TCmalloc的线程局部分配器优化，CPU内部都拥有分配缓冲区，cache空时继续分配则从全局分配器调入内存，cache满时释放一半内存。局部分配器分配内存时不关中断，当发生中断嵌套使用时自动切换为全局分配器。

## 内存释放优化

buddy_system_allocator内存释放的时间复杂度是O(N)，是否有更高效的实现方法？

### 定期回收策略

每次释放内存都遍历链表效率太低，修改定期回收策略。对每个链表，设上一次回收后的长度为N，取一合适的k值（如2），当释放内存使链表长度到达kN且kN大于某个常数C时进行回收。合并段的方式为先整体排序，临时调入最大长度的连续内存，将整个链表写入这个段后使用随机访问的快速排序，合并完成后写回链表。如果连续内存空间不足可以使用链表上的快速排序，性能相对随机访存的快速排序会明显下降。回收的时间复杂度是排序的O(NlogN)，平均复杂的降低至O(logN)。分配内存的复杂度为O(1)，且不会在大量重复分配释放时出现大量拆分合并，这是FTL OS目前采用的优化策略。

### 使用更快的容器

可以使用时间复杂度更低的容器来替换缓慢的链表。树状数据结构会将释放内存的复杂度降低至O(logN)，但也将申请内存的时间复杂度提高至O(logN)。集合的节点需要使用其他动态分配的方式，这会产生更高的内存开销。

## Per-CPU内存分配缓冲区

内存分配的过程耗时不少，而且是竞争非常严重的区域。如果我们在每个CPU开设一块缓冲区来缓冲内存分配，当缓冲区满或空时批量地从全局分配器分配内存，那么就可以大幅降低多核竞争开销。

为什么不直接在每个CPU上放置独立的内存分配器，一劳永逸地删除多核竞争？这会导致一种潜在的错误：一个CPU不断地分配内存，这些内存在另一个CPU上释放。如果这个情况发生了，那么就会出现实际内存还有很多，但某个CPU却没有内存可以分配的情况。要想解决这个问题则必须加入CPU间的通信手段，这就带来了同步开销，必须使用原子操作。

FTL OS不喜欢原子操作，采用了per-CPU内存分配缓冲方案。每个CPU的缓冲区只有各自的CPU可以访问，完全禁止其他核从缓冲区窃取内存。这会带来一些内存浪费，FTL OS的缓冲方案为从8字节到2048字节，大体上每个幂次使用4 KB的缓冲区，每个CPU的最大缓冲区大小为36 KB，和整个内存相比不值一提，但却能显著提升了内存分配的速度。

还有一种潜在的错误。内存分配的过程可能发生中断，而如果在分配内存时发生了中断，而中断处理程序里又尝试分配内存，那么操作系统非崩即残。

FTL OS不喜欢关中断，因为关中断会清空流水线带来巨大的性能损耗。操作系统的安全比性能更重要，但我们也希望用很少的性能损失来解决这个问题。FTL OS在内存分配缓冲区上放置了一个标志位来标识分配器是否正在被占用，每次分配内存之前会先向标志位写入true，释放完成后写入false，两个写入操作需要编译内存屏障防止重排序。如果分配内存时发现标志位为true，这就说明在内存分配期间发生了中断，此时改为从会关闭中断的全局分配器分配内存。

