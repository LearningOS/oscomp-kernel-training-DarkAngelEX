# 内存分配器

常见内核都使用buddy伙伴内存分配器，它以2幂划分空闲内存至各个集合，分配内存时从对应大小的集合取出一块，如果不能取出则从上级集合分裂出对应大小的内存。释放时放回对应的集合，并判断集合中是否存在可以合并的另一块内存，如果存在则合并这两块空间，加入合并后对应的集合。

rCore-tutorial采用了第三方库的buddy_system_allocator分配器作为全局的堆分配器。此分配器使用链表管理同大小的集合，默认分配器内部的内存块不存在其他的引用，直接在每个内存块头部保存一个指针，利用此指针将各个内存连成链表，为了保存指针，最小的可分配空间为8字节。buddy_system_allocator释放内存的合并策略是扫描整条链表寻找伙伴，因此每次释放操作的时间复杂度是O(N)，内存碎片越多性能越低。

TCmalloc是google开发的高速内存分配器，使用线程缓存技术在每个线程放置了内存分配缓存，从分配缓存中分配内存不需要获取锁。

## FTL OS内存分配器实现

FTL OS希望构造一个高速的内存分配系统，希望兼顾性能和安全时尽可能简单。

rust保证了不使用unsafe时，智能指针管理的内存释放后保证不存在悬挂指针，因此内存分配器使用在内存块内放置指针的策略，保证不使用释放后的内存。

> 事实上，如果如C++一样在内存分配区域之前放置元信息会导致极大的空间开销，因为大部分分配的内存大小都是2的幂，如果分配大小增大一点点，分配器就会将其看作下一个幂，空间直接损耗了50%！

加入TCmalloc的优化很简单，只需要在每个CPU设置内存分配cache即可，cache空时继续分配则从全局分配器调入一半cache。cache满时释放一半cache。

## 内存释放优化

buddy_system_allocator内存释放的时间复杂度太高了，是否有更高效的实现方法？

### 定期回收策略

每次释放内存都O(N)搜索太慢了，可以修改定期回收策略。对每个链表，设上一次回收后的长度为N，取一合适的k值（如2），当释放内存使链表长度到达kN且kN大于某个常数C时进行回收。合并段的方式为先整体排序，临时调入最大长度的连续内存，将整个链表写入这个段后使用随机访问的快速排序，合并完成后写回链表。如果连续内存空间不足可以使用链表上的快速排序，性能相对随机访存的快速排序会明显下降。回收的时间复杂度是排序的O(NlogN)，平均复杂的降低至O(logN)。分配内存的复杂度为O(1)，且不会在大量重复分配释放时出现大量拆分合并，这是FTL OS目前采用的优化策略。

### 使用更快的容器

可以使用时间复杂度更低的容器来替换缓慢的链表。树状数据结构会将释放内存的复杂度降低至O(logN)，但也将申请内存的时间复杂度提高至O(logN)。集合的节点需要使用其他动态分配的方式，这会产生更低的内存开销。
