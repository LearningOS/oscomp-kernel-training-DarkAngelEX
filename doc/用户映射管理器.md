# 用户映射管理器

XV6实验使用硬编码方式在usertrap中对地址进行分析，判断不同地址的处理方式。这会导致每个地址只能用于特定的用途，并极大地增加维护成本。

我们希望能够有一种解耦的方式来管理用户地址空间，增加后续功能时不再改动代码的其他区域。

rCore使用了handler来管理用户映射区域。handler是一个trait，实际发生页错误时错误处理不再需要关注handler的具体类型，只需要调用对应的页面处理函数即可。听起来非常好，但实际使用会遇到问题。

FTL OS采用了无栈协程，这意味着每个上下文切换点都是固定的，不能在内核的中断处理函数中切换上下文。同时FTL OS采用了基于await的睡眠锁，因为文件读写是可阻塞的。rCore方案在页错误处理时使用阻塞读取，这会导致多线程程序触发页错误时所有核都阻塞在错误处理程序动弹不得，一核有难八方阻塞。

为了阻止长时间阻塞的发生，FLT OS定义了自旋锁的guard的!Send trait来阻止持有自旋锁时跨越await，并要求自旋锁连续阻塞时长不能超过100ms，保证核心的高效利用。这意味着handler的异步函数不能如rCore一样直接来一个&mut PageTable，因为获取可变引用的唯一可能就是持有了一个锁。

# 问题

handler不能持有锁，那么管理器放在哪里？

管理器需要哪些参数？

怎么尽可能减少锁的使用？

# 设计

## 必要数据

页表，包含satp寄存器，asid版本号，涉及底层被自旋锁保护，不可跨越await。

handler：包含了页错误发生时该对页表做什么，异步函数。

段至handler的map。

放置页表和handler_map的user_space。

## 思考

handler从磁盘中读取数据需要先写入内存上的缓存块，此为await异步操作，因此不能在调用此函数之前获取页表的可变引用。

页错误发生时的处理过程：获取错误地址，找到handler，从文件读入数据，写入页表。

页表的可变引用在最后一步才用得到，因此可以延迟获取页表的时间。从user_space找到handler后直接复制一份，释放user_space的锁后再调用处理函数。

页表指针可以从task_local获取到。

页表需要增加closed状态来表示此页表对应的进程已经退出了，这个页表已经无效了。

### 如何防止线程A在页错误进行文件读入时，内存映射被线程B修改，之后线程A对页表的无效位置进行映射？

考虑增加map区域64位版本号，每次映射新的区域都会修改版本号。文件读入完成后先检测版本号再修改页表。这样handler就不仅需要获取页表了，还需要获取整个user_space的锁。似乎也不是不行？

想法A：将user_space改为Arc。

问题：Arc导致user_space无法直接获得可变引用，需要加锁。但原设计里user_space直接放置在alive_process中，如此获得进程锁即可获得页表锁，否则需要两次锁操作。

当前方案：直接保存Arc<Process>，从进程直接获取user_space可变引用。

## handler应该如何设计？

### 需求

为了节约内存，handler并不是内存页的一一映射，而是对内存段的一一映射。

为了减少handler的数量，handler必须可以方便地合并。

为了加快查找速度，handler采用BTreeMap维护。

### 想法

handler管理一个映射段，但由于handler处于数据结构中，因此进行查找时即可获取内存段信息，handler不需要放置映射段信息。

更进一步，handler不保存可变状态，运行时从函数参数直接获取相关信息。如此handler便可以看作是一个懒求值函数，当发生页错误时调用对应的函数获取相关信息。这样handler不再需要获取可变引用，可以使用Arc保存。

handler的所有权由当前页表获得，那么用Box

由上层数据结构负责函数参数的正确性检查。

### 页表段的操作

fork时懒分配可写段如何转入COW段？

已分配的：COW操作去除写标志位

未分配的：保持懒分配状态，不作变化。

页错误处理时COW段如何转入可写段？

增加写标志位。将COW段的错误段改为可写段。

fork时改变handler类型好麻烦啊，似乎唯一改变handler类型的地方是COW，是否可以在页表层代理COW？

映射页所有权有两种，一种是唯一页，由页表释放空间。另一种是共享页，由外部释放空间。COW属于共享页。

页表中含有2个RSW位，取其中一个表示共享标志。共享标志表示已经在共享管理器中注册了这个页，不再由所在页表的handler释放空间。

页错误时由handler检查是否可写。

### 具体流程：

以下函数出错时只需要撤销线程而不是进程。

exec：userspace准备好后对全部段执行一次init_map。

首次创建页：由handler分配并在页表中映射内存。

fork：

无共享标志位：由handler确定是否共享。

如果共享则增加共享标志，从handler中取出共享写标志位。

如果不共享则复制映射区域。

有标志位：直接映射到新的区域。

尝试映射：

未映射：由handler调用页错误分配函数。

映射但写错误：从handler取出所有权写标志并判断。成功后判断引用计数，如果引用计数为1则直接获取页所有权并去除共享标志位，设置写标志位。

异步映射：

尝试处理完成后即弃用进程锁，分配新的内存处理页错误。异步操作完成后再次获取进程锁，获取range对应的handler_id，id是递增分配的唯一标识，确认后再映射到对应的区域。

可能有两个线程对同一个地址发起异步映射！因此最终映射时需要判断是否已经被映射，如果已经映射了则取消操作，但不需要终止进程。

取消映射：

非共享页：由handler释放空间

共享页：获取并递减引用计数，如果旧值为1则由handler释放空间，回收引用计数。

重映射：

直接暴力对重复位置取消映射，加入新的映射。

TLB刷新：

定义：TLB内部不存在一直无效的映射。只要保证这一点就可以不在发生页错误的时候刷表，而是在释放空间的时候刷表，同时刷表请求会发送至其他的CPU。

这会延迟其他CPU获取正确地址的时间，不过问题不大。CPU可能会发生（错误的）页错误，但只需要获取页表锁后再判断一次即可。

### 引用计数放在哪？

锁竞争越少越好，空间越小越好。

暴力方案A：在内存上放置引用计数数组，可以采用每连续512个页一组（2MB），第一个页不加入帧分配器，而是作为COW引用计数数组。所有页可以直接从物理地址获取引用计数地址。这会导致无论内存多大都无法分配超过2MB的连续内存。

方案B：堆上动态分配引用计数空间。每个COW页对应一个计数器。这会导致Arc指针原子开销，没什么其他缺点。

不能直接用Arc的引用计数！因为Arc原子递减不提供返回值。

# 需要的接口

## 页表

将底层映射从单纯的内存分配抽象为函数。

## handler

禁止可变引用接口

禁止fork或页错误后变为新的handler

fork后产生相同的handler

id 异步检测使用

是否共享分配与共享写标志位 Option<bool>

所有权访问标志

尝试无阻塞映射

无阻塞复制映射

页表段(异步)映射

页表段全部释放

## 引用计数管理器 MAP va => Arc<AtomicUsize>

使用va而不是pa来加速获取

原子递减引用计数，并返回是否递减前是否为1。

原子操作不对外公开！仅提供插入与删除。插入增加引用计数，删除减少引用计数。

## MAP Range=>handler

拥有handler所有权

insert / remove

## 映射段管理器

见具体流程。

# 共享映射设计

此映射管理器代理全部的共享映射，保证调用handler时都是拥有所有权的。