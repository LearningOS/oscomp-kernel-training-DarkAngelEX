# RCU智能指针

智能指针通过引用计数来管理资源，所有智能指针都指向同一块内存，这块内存出了数据之外还携带两个引用计数，分别代表指向这块内存的强指针和弱指针数量。当强引用计数归零时会调用资源的析构函数，当弱引用计数归零时会释放这一块内存。

单线程的环境下更新引用计数非常简单，只需要先读取引用计数，修改后写回即可。但在多核环境下，如果两个核同时修改引用计数，那么只有一个核的结果会留下来。为了保证引用计数更新的正确性，我们必须使用原子指令来保证它的正确性。

有什么办法能够干掉这条讨厌的原子指令呢？如果我们放宽对析构即时性的要求，允许机构延迟到多次调度之后，那么就可以利用一些方式来避免大量的原子操作，例如垃圾回收。很多人对于垃圾回收有误解，认为垃圾回收会显著降低性能，这种说法是片面的，因为如果仅从吞吐量的角度来看，垃圾回收反而比智能指针更快，这是因为垃圾回收期间被成为STW，此时只有一个回收线程在运行。在单线程环境下完全不需要原子操作来进行多核同步，因此垃圾回收的吞吐量比原子计数的方式高得多。垃圾回收最大的问题是STW期间程序完全无法工作，这就会导致程序不定期的卡顿。

对于内核来说，我们并不需要用垃圾回收来管理全部的变量。大多数语言使用图遍历的方式来支持垃圾回收，这是因为图遍历具有最广的实用性，而且可以一次性释放全部可以释放的变量。而如果我们的智能指针的释放有延迟，那么对于一个这样的智能指针组成的链表，此链表的末尾节点会在很远的未来才会被回收，这增加了内存的使用量。但还是那句话，不同的东西有不同的场景，我们完全可以让RCU智能指针只运行在获取释放最频繁的部分。

## 设计

我们的目标是让RCU智能指针在没有任何核心更新后被回收。这可以通过标记位做到，我们让每个CPU占有一个字节的标记位，如果修改了引用计数就会将标记位设为1。在回收阶段，回收核心会遍历每个标记位，只有所有标记位都为0才会进入下一个阶段，否则将标记位写入0。考虑一个8核心的场景，我们可以将标记位聚在一起，这样就可以用一条双字加载来读取全部的标记位了。只要标记位是0，就说明从上次回收到现在这个智能指针都没有被使用。

接下来是引用计数。我们依然让每个CPU持有1个字节的引用计数，这个引用计数即使在回收阶段也不会被改变。这个引用计数是有负数的，因为可能一个核心生成了智能指针后发送至另一个核心释放。于是我们还需要在最后开设一个8字节的原子引用计数，当自身的引用计数溢出后就会原子地搬运到这里。

## 竞争状态的正确性

标记位是各个CPU和回收CPU通信的手段，我们需要通过内存序来保证它的正确性。对于修改智能指针的核心，它会先将标记位设为1，然后再写入新的数据。对于回收核心，它会先读取数据，再读取标记位，再判断读取的数据。这就保证了当我们观测到标记位为0时，之前读取到的数据一定是上次回收写入0之前的数据。如果其他CPU在这里发生了竞争，那么上次回收写入0之前智能指针的引用计数一定不是0，因此回收核心不会回收这个智能指针。

事实上，我们可以把标志位和引用计数聚成一个16位成员，这样就不用管奇奇怪怪的内存序了，毕竟一条指令就可以完成读写。

## 降低垃圾回收压力

什么时候判断这些成员能不能释放？最简单的方式就是和jvm的垃圾回收一样，把全部的RCU智能指针扫一遍。不过我们可以更进一步，在RCU智能指针析构的时候修改引用计数，然后用RCU释放一个回收任务。不过如果我们频繁的获取再释放RCU智能指针就会占有大量的队列节点，我们可以继续利用CPU的标记位，如果提交了释放任务，那么它的值将是2，如果析构时值不是2，那么就立刻提交一个释放任务，然后将值写入2。

这依然会带来一个问题，那就是如果在回收任务执行之前最后一个智能指针释放了，那么回收核心会因为标志位的原因拒接它的回收，但是接下来再也不会有回收任务了，因此我们需要让回收任务延后运行。即当回收任务提交后，下一次回收时刻只会清除标志位，而这时它会再加入回收队列。回收任务会在队列中转两圈，如果它应该释放，那么它会在第二次回收时刻被释放。

我们有没有可能提前回收资源？这样就连队列资源都用不上了。只需要判断其他核心的标志位是不是0即可，但这样我们就需要防止多个核心同时回收同一个资源，于是回收时就需要上原子操作了。不过，这种情况真的会发生吗？我们完全可以不修改引用计数，这样回收核心永远都不会回收这个资源了。唯一的问题是如果我们回收了资源，那么这块内存也没了，然后回收线程就会访问一个完全错误的地址。从这个角度看，一旦采用了这种方式，提前回收就再也不可能了。

## 用途

设想是想用来替代文件的，但延迟释放这个性质似乎不太好把控。FTL OS尚未应用RCU智能指针。