# 进程间通信

## 事件总线

FTL OS的进程间通信方案参考了rCore的实现。每个进程都持有一个事件总线（`EventBus`），事件总线是其他进程通知本进程的唯一方式并自身有独立的锁保护，向事件总线发送消息不需要获取对应进程的锁。引入事件总线可以有效地解决进程释放时潜在的死锁，对于初始进程G，某父进程A和它的子进程B，当A和B同时退出时：

* A需要通知B其父进程修改为G，并将他放入G的子进程集合中。
* B需要通知A自身变为了僵尸进程。

![image-20220526145925170](pic\事件总线-死锁.png)

在不使用事件总线时，如果两个事件同时发生则产生了A指向B和B指向A的有环图导致死锁，如果想解决这个问题需要加入更加复杂的处理逻辑，而这个问题并不是只在退出进程时会遇到。但使用事件总线则可以一劳永逸地解决死锁的问题，因为事件总线的锁被封装了，操作事件总线时无法获取另一个锁，因此事件总线永远不会成为环的一部分。

为了防止关闭进程导致的事件丢失，事件总线提供了原子的获取-关闭操作，进程退出之前将关闭事件总线，此时事件总线会返回所有积累的事件，在此之后不再接收任何消息。关闭的事件总线不能再次打开，因此事件总线可以作为僵尸进程的标志。初始化进程G被定义为不可退出的，因此永远可以向G的事件总线发送消息。因此上述的进程退出竞争将会：

* A进程向B进程发送父进程变更消息，向G进程发送A变为僵尸的消息与A的子进程添加的消息。
* B向A发送自身变为僵尸进程的消息。

![image-20220526145802127](pic\事件总线-解决.png)

使用了事件总线后有环图变为了无环图。由于A和B处于退出状态，因此事件的发送可能失败，对发送失败的处理为：

* A向B发送父进程变更消息失败，这意味着B变为了僵尸进程，改变父进程毫无意义，放弃发送消息。
* B向A发送自身变为僵尸进程的消息失败，这说明自身变为了G的子进程，因此向G发送自身变为僵尸的消息。

尽管事件总线能有效避免了死锁，但也让消息的顺序变为了不确定的状态，例如B向G发送的变为僵尸进程的消息可能先于A发送的子进程变更消息到达。FTL OS引入了“僵化”状态，变为僵尸的进程如果未在子进程集合中找到将处于僵化状态，收到实际的进程后再变为僵尸状态。

引入事件总线后除了数据传输（通过管道）外所有的进程间通信操作都通过事件总线进行。事件总线收到可以处理的事件后将唤醒进程。事件总线的处理单位是以进程为单位，而一个进程可能包含多个线程，因此当前的处理方式是唤醒全部线程，因为FTL OS中的异步执行模型保证了误唤醒只会降低增加调度开销而不会导致错误，在未来会追踪每个事件的处理者并只唤醒对于进程。

## 管道

管道是在两个不同进程之间传输数据的常用方式，一个进程向管道写入数据后另一个进程可以从管道读出数据，如果缓冲区空或满都会阻塞相应的操作。常用的管道实现中管道只允许被一个写者或一个读者占用，这种方式非常安全且简单，但FTL OS更进一步，允许管道同时有一个读者和一个写者同时存在，由原子操作保证管道的正确运行。

管道缓冲区是16 KB的循环FIFO，由4个4 KB的内存组成，初始化完成后缓冲区大小不再变化，未来可以通过RCU在并发状态下动态地改变缓冲区的占用内存。缓冲区包含两个标志原子变量，分别为`read_at`和`write_at`。对于读者来说，从`read_at`到`write_at`的空间是可以读取的，对于写者来说，从`write_at`到`read_at`的空间是可以写入的。读写两侧都会完成数据操作后再更新各自标志位，标志位更新就意味着另一侧可以观测到这部分更新了。由于FIFO被分为多片内存，因此数据的最大操作单位为4 KB，每操作4 KB的数据就会更新一次标志位，防止了输入数据过大导致的死锁。

管道运行于异步上下文，因此读写两端都由睡眠锁保护。FTL OS认为管道的并行读取和并行写入是没有意义的，因为管道的操作单位是字节而不是数据块，并行的读写只会得到乱序的无效字节，因此没有进一步在缓冲区上应用wait-free读写优化。`read_at`和`write_at`的更新需要内存屏障。以下展示了管道并行读写时数据和标志的变化：

![image-20220526144557790](pic\进程间通信-管道.png)

>蓝色的是可以读取的数据，橙色是可以覆盖的无效数据，绿色是已经读取但无法被写入的数据，紫色是已经被写入但无法被读取的数据。

频繁的调度会增加内核开销，FTL OS将尽可能减少数据传输时的调度次数，即使要传输的数据超过了16 KB。由于管道缓冲区的读写是由`read_at`和`write_at`保证的，因此只要任意一个发生了变化就意味着另一侧有了数据操作空间。每次数据分片操作完成后管道会重写读入`read_at`和`write_at`，如果发生了变化就说明管道获取或被取出了数据，此时将重新开始管道读写。当读取速度和写入速度相同时一次调度就可以完成数据传输，如果速度不匹配则速度较快的一方可以出让CPU降低开销，直到被另一端唤醒，而速度较慢的一方将在缓冲区满时出让CPU。