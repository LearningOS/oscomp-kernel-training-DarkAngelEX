# FAT32文件系统

FTL OS的FAT32文件系统是异步文件系统，支持完善的多核并发操作，缓存块管理和无阻塞写与异步IO，严格按照Unicode标准处理字符串。由于文件系统的具体实现非常复杂，具体细节请直接阅读源码，此文档只说明重点部分。

文件系统按模块可划分为：

| 模块     | 用途                        |
| -------- | --------------------------- |
| layout   | 磁盘数据布局定义            |
| block    | 缓存块管理模块              |
| fat_list | FAT簇分配链表管理模块       |
| inode    | FAT inode管理模块           |
| manager  | FAT32文件系统的唯一对外接口 |

## 磁盘布局

FAT32文件系统在磁盘上被划分为如下的多个部分：

### MBR(Main Boot Record) 主引导记录 446字节

MBR是计算机启动加载，解释分区结构，包含物理上的0扇区。

### DBR(DOS Boot Record) DOS引导记录

DBR是操作系统访问的第一个扇区，用来解释文件系统。这里的第一个扇区作为逻辑0扇区，接下来的描述以此为基准，访问扇区时要偏移。

### FAT table

FAT分区表维护了每一个文件的簇链表。取值如下：

| 簇号         | 描述 |
| ------------ | ---- |
| 0            | 空闲 |
| <0x0FFFFFF7  | 后继 |
| =0xFFFFFFF7  | 坏簇 |
| \>0x0FFFFFF7 | 末尾 |

FAT表中0号位与1号位是无效的，0号位的值永远为0xF8FFFF0F，1号位的值为0xFFFFFFFF/0xFFFFFF0F。

FAT32文件系统可能包含多个FAT表且互为备份。

### 数据段

FAT32文件系统的数据段放置在FAT table之后，并延续到分区的末尾。数据段按簇管理，每个簇包含多个扇区。绝大多数文件系统的簇大小为4KB，对于512字节的扇区，一个簇包含8个扇区。不像ext文件系统将inode和数据块分开管理，FAT32文件系统中文件和目录的数据都放置在数据段中。

## 短文件名与长文件名

一个文件名项占用空间为32字节，因此一个4KB的簇可以放置128个项。短文件名格式为8.3（字节数），文件名部分不可为空，如果扩展名为空则输出的文件名不包含末尾的点，因此短文件名不能表示除了"."与".."之外末尾包含点的文件名。文件名项第一个字节为0x00时表示空闲，0xE5表示文件名项已释放。如果包含0x40位且不包含0xA0位说明是最后一个长文件名，此时低五位为顺序号。

无扩展的短文件名不能出现小写字母，因此出现小写字母就要使用长文件名表示，对应的短文件名将变为大写字母。windows支持短文件名中的保留标志位中文件名大小写扩展，全小写文件名可以只用一个短文件名表示。

一个长文件名项可以储存13个utf-16编码字符。当无法正好填充时，下一个位置将填充0x0，之后的空闲位置填充0xffff。文件的每个长文件名都有各自的编号，此编号的最大值为31，因此FAT32文件系统最多支持403个字符。

## 基于try的惰性扫描

Haskell中惰性求值是一项基础语言特性，计算时只会数据结构的必要部分求值，利用惰性求值Haskell可以表示出无限链表等在普通语言中难以做到的数据结构。haskell中foldr函数定义如下：

```haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
```

逻辑上foldr是对链表从右向左折叠，但在实际求值中是从左向右计算的。由于haskell的惰性求值特性，foldr中参数f可能不需要对x:xs求值，此时foldr不再需要遍历余下的链表而直接返回。惰性求值让foldr可以输入无限列表，并在有限时间内返回结果。

rust的标准库也提供了惰性求值支持，相对于Haskell，rust只能在函数中显式返回，而问号语法为此提供了便利:

```rust
fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
where
	Self: Sized,
	F: FnMut(B, Self::Item) -> R,
	R: Try<Output = B>,
{
    let mut accum = init;
    while let Some(x) = self.next() {
        accum = f(accum, x)?;
    }
    try { accum }
}
```

这是标准库中`try_fold`的函数定义。在`f(accum, x)?`处会对返回值进行判断，如果返回值为`R::Residual`，`try_fold`将直接返回。它与haskell中的`foldr`并不等价，因为折叠的方向不同。

FTL OS文件系统使用`try_fold`封装对缓存块的操作，并在此基础上继续构造出一系列目录项处理操作。使用`try_fold`而不是迭代器的原因是`try_fold`和迭代器运行的位置不同，`try_fold`的参数函数运行在栈的最深处，而迭代器是从函数的返回值中获取值。`try_fold`可以作为深层异步函数的一个部分运行，而迭代器除了需要将自身异步化外，每次调用都涉及内部上下文的切换，在文件系统中的表现为`try_fold`只需要获取锁一次，而迭代器每次取出数据都要获取锁，除了开销更大外还导致了潜在的数据不同步问题。

## 缓存块层

文件系统采用异步驱动，因此缓存块读写也是异步化的。缓存块使用异步睡眠锁保护，当进程阻塞于睡眠锁时不会消耗CPU资源。缓存块只能经inode层修改，不暴露对外接口。

为了提高性能，文件系统使用无阻塞写策略，除了脏块到达上限外，inode写操作不会阻塞。为了实现无阻塞写，文件系统构建时将产生一个只运行在内核态的磁盘同步线程。每个磁盘写操作都会将缓存块标记为脏并提交至同步等待集合，磁盘同步线程则取出磁盘同步集合并对每个簇生成一个微线程，这为高性能并行IO提供了可能。最后一个微线程执行完成后会唤醒同步线程，同步线程将反馈同步结果至块缓存管理器，所有在同步期间没有被写入的缓存块的状态将变回clean。

多核环境中无阻塞写必须保证提交至驱动的内存处于不可变状态，即使缓存块在驱动写期间被其他线程修改。为了保证这一点，FTL OS使用了可以在唯一状态和共享状态自如转变的缓存。定义如下：

```rust
// fat32/src/block/buffer.rs
pub(crate) enum Buffer {
    Unique(Box<[u8]>),
    Shared(SharedBuffer),
}
#[derive(Clone)]
pub(crate) struct SharedBuffer(pub Arc<Box<[u8]>>);
```

缓存块的大小是可变的，在大多数文件系统中大小为4KB。`Buffer`可以在唯一状态和共享状态之间自由转换，且当引用计数为1时转变为唯一状态不需要复制内存，不为1时将分配新内存并从共享内存中复制资源。`Buffer`保证了唯一状态不存在其他的引用，共享状态的内存不会被修改。缓存块`Cache`使用睡眠读写锁封装`Buffer`，保证并发的安全。同步线程只需从可变的`Buffer`获取`SharedBuffer`即可保证数据不变性。

## 缓存块管理

磁盘的大小可能达到数个TB，这种情况下缓存整个磁盘是不可能的，而缓存块有限时需要考虑缓存块的替换。无阻塞写策略下缓存块具有clean和dirty两种状态，而只有clean状态的缓存块是可以回收的，因此如果所有缓存块都为dirty，要么超出最大缓存块限制继续分配，要么阻塞获取操作直到某个dirty的缓存块同步完成。这会导致潜在的饥饿，因为如果缓存块在同步完成之前又被写入了，缓存块将依然处于脏状态。FTL OS使用信号量限制脏块数量保证不会到达缓存块数量上限，每个脏块都持有信号量，只有状态变回clean时持有的信号量才会释放。脏块数量限制不能保证可以找到一个可替换的块，因为只有不被持有缓存块才是可替换的。所有缓存块都被持有的概率很低，这种情况下文件系统将操作失败并返回ENOBUFS错误码。

FTL OS的文件系统使用RLU替换策略。缓存块管理器可以原子分配时间戳，缓存块具有一个时间戳字段。每次对缓存块的访问都会更新时间戳字段，但这个字段只会在缓存块替换时被访问。所有缓存块都处于按时间戳排序的有序集合中，但排序使用的排序时间戳仅保证不大于缓存块上的实际时间戳。替换时从时间戳的最小端开始寻找，只有排序时间戳和实际时间戳相等时才进行替换，否则更新排序时间戳并将缓存块放入正确的位置。这种替换方式里每次访问只有一次原子地址递增开销，但缓存块替换时开销较大，被访问的缓存块越多耗时越长。由于时间戳分配器是全局的，分配时间戳的竞争也非常大。

一种有效加速替换且减少竞争的方式是放弃LRU替换策略改为时钟替换策略，所有缓存块都放置在一个循环链表构成的时钟轮盘上，每个缓存块维护一个标志位。每次缓存块的访问都会将对应标志位设为1，而时钟经过缓存块时判断标志位，如果为0则直接替换，如果为1则改为0。这种方式在访问缓存块时只有一次额外访存开销，缺点是相对RLU会增加缓存块的查找和替换次数。当缓存块数量较多时替换次数将非常少，但减少的一次原子指令能明显提高性能。另一种方式是使用多代LRU算法，将所有缓存块放置在多条链表上，每次缓存块访问都会提升缓存块所属级别，但提升至最高级时不再提升，此时不再发生锁竞争。缓存块查找时只会在最低级的链表查找，当链表为空时所有链表都降低一个级别，此方法经过优化后可以在降低级别时不需要修改每一个缓存块上的信息，速度很快。

## 缓存块索引器

每个缓存块都对应一个磁盘上的簇，因此簇号是缓存块的唯一标识。获取缓存块自然可以在缓存块管理器中获取，但缓存块管理器被睡眠锁保护，竞争和锁开销非常大。为了提高性能，FTL OS在缓存块管理器的睡眠锁之外加入了缓存块索引器，查找缓存块时优先从索引器查找，当索引器查找失败时再进入缓存块管理器中查找缓存块。索引器定义如下：

```rust
// fat32/src/block/index.rs
pub(crate) struct CacheIndex(RwSpinMutex<BTreeMap<CID, Weak<Cache>>>);
```

可见索引器就是一个由读写自旋锁保护的映射。由于索引器只是不持有所有权的加速结构，因此映射结果也不持有所有权的弱指针。只有成功通过`upgrade`获取缓存块的强指针才是一次成功的索引器查找，索引器发生未命中则会在缓存块管理器进行缓存块查找，查找结束后将更新索引器，保证未命中至多在每个CPU发生一次。索引器在释放管理器睡眠锁后更新来减少缓存块管理器的持续占用，这可能存在由乱序更新导致的轻微内存泄露（长时间存在一个失效缓存块的索引），但不影响程序的安全性。

## 高并发的FAT表

许多文件系统的实现将FAT表看作一个对象并使用读写锁保护，例如2021届操作系统比赛冠军Ultra OS就使用了读写锁来保护FAT表。这样实现无可厚非，但FTL OS对FAT表有更进一步的高并发设计。FAT表在磁盘上占有大量的簇，将如此大的空间看作一个对象将极大地降低并发度，一个例子是两个互不相关的线程正在分别独立地读与写文件A与B，写文件B获取的FAT表写锁会阻塞读文件A，但这是两个不同的文件，拥有的FAT链表也是不相同的，为什么要相互干扰降低性能呢？FTL OS仅仅将FAT表看作一块磁盘上的空间，空间上分布了许多各自属于对应的文件的FAT链表，对一条链表的操作不会阻塞其他链表的操作。此设计下某文件分配簇的过程完全不会阻塞到其他文件对所属簇的读取，只要它拥有的链表存在于缓存中。

FTL OS的文件系统支持TB级磁盘，不会将整个FAT表放入内存。与缓存块不同，FAT表缓存以扇区为单位而不是以簇为单位，替换策略与缓存块一样使用LRU替换策略。FAT链表分配涉及大量数据修改不可并发，因此FAT表的磁盘IO和簇分配都在FAT表管理器中进行并由读写锁保护。

和缓存块管理器相同，FAT表采用了无阻塞写策略，管理器初始化时将生成一个只在内核态运行的同步线程。

### FAT表索引器

FAT表索引器除了提供加速查找作用外，更重要的是它不处于管理器睡眠锁的作用范围，管理器处于占有状态时依然可以查找。由于FAT表的使用频率较大，索引器没有使用`BTreeMap`，而是使用了数组来实现更快的查找。索引器定义如下：

```rust
// fat32/src/fat_list/index.rs
pub(crate) struct ListIndex {
    weak: Box<[UnsafeCell<Weak<ListUnit>>]>,
    lock: Box<[RwSpinMutex<()>]>,
}

pub(crate) struct ListUnit {
    buffer: UnsafeCell<Buffer>,
    aid: UnsafeCell<AID>,
}
```

索引器并不是对单个项的索引，而是对一个FAT表扇区`ListUnit`的索引。在文件系统中FAT链表的修改只能在FAT表管理器中进行，所有修改都是串行化的，因此这里系统使用了`UnsafeCell`来提高性能。和缓存块索引器一样，索引器的弱指针可能是无效的，此时需要进入FAT表管理器再次获取索引。索引器使用读写自旋锁的原因是多核环境下操作智能指针是不安全的，文件系统允许多个线程同时操作FAT表的同一个缓存扇区，由于CPU Cache的存在，写线程释放了旧的Weak指针后可能无法及时通知到读线程的Cache，此刻读线程将获取到一个已经被析构的弱指针，进行任何操作都会导致内核出错。最简单的解决方法就是上锁：

```rust
// fat32/src/fat_list/index.rs
pub fn get(&self, index: usize) -> Option<Arc<ListUnit>> {
    let _lock = self.lock[index].shared_lock();
    unsafe { (*self.weak[index].get()).upgrade() }
}
pub fn set(&self, index: usize, arc: &Arc<ListUnit>) {
    let _lock = self.lock[index].unique_lock();
    unsafe { *self.weak[index].get() = Arc::downgrade(arc) }
}
```

另一个方式是使用RCU释放Weak指针，这个方式的读者不需要上锁：

```rust
// fat32/src/fat_list/index.rs
use ftl_util::rcu::RcuCollect;

pub fn get(&self, index: usize) -> Option<Arc<ListUnit>> {
    unsafe { &(*self.weak[index].get()) }.rcu_read().upgrade()
}
pub fn set(&self, index: usize, arc: &Arc<ListUnit>) {
    let _lock = self.lock[index].unique_lock();
    unsafe { &mut (*self.weak[index].get()) }.rcu_write(Arc::downgrade(arc))
}
```

rcu系统不会立刻析构旧的弱指针，而是等待所有CPU离开宽限期才释放弱指针，因此`get`函数实现中的`rcu_read`总是有效的。`rcu_read`仅需要一次访存和一次读内存屏障，相对于读写锁的两次原子操作能明显提升性能。

索引器的数组长度与FAT表的扇区数量相同，每个FAT表扇区需要8 B的指针。对于扇区大小为512 B，簇大小为4 KB的1 TB磁盘，FAT表的大小为1 GB，索引器的空间开销为16 MB，因此文件系统可以轻易支持TB级别的磁盘。

## 文件inode

FTL OS中inode是用户操作磁盘数据的唯一方式，一个inode对应一个文件，也拥有对应FAT链表表的所有权。由于FAT32文件系统特性，文件系统中包含两种inode：目录inode和文件inode。为了提高性能，inode被分为了两个部分，inode缓存和inode句柄。每个inode句柄都对应至一个inode缓存，只有虚拟文件系统的inode持有inode句柄的所有权，因此虚拟文件系统的inode引用计数归零析构时也将析构inode句柄。但inode句柄的析构并不意味着inode缓存立刻析构，inode缓存使用和缓存块相同了LRU替换策略，当缓存数量达到上限时将替换已有的inode缓存块。inode缓存不存在需要写回磁盘的数据，如果inode缓存的引用只被管理器持有就可以直接替换。

|  inode缓存数据  | 描述与作用                              |
| :-------------: | :-------------------------------------- |
| inode弱指针索引 | 不经过缓存管理器直接获取缓存对应的inode |
|  文件名项地址   | 磁盘上此文件的短文件名位置              |
|   FAT链表缓存   | 此文件所属文件的FAT链表缓存，懒加载     |
|  FAT链表首簇号  | 此文件FAT链表的第一个簇号               |
| FAT链表的末簇号 | 此文件FAT链表的最后一个簇号，懒加载     |
|    文件簇数     | 簇链表的长度                            |
|   短文件名项    | 此文件短文件名项的副本                  |

inode缓存使用读写自旋锁保护，每次inode的FAT链表查找都会更新inode缓存。inode自身由读写睡眠锁保护，当涉及文件大小修改或簇的分配与释放时必须获取写睡眠锁。FTL OS的文件系统对inode的操作进行了更高粒度的划分：

| inode操作                | 获取的锁    |
| ------------------------ | ----------- |
| 读文件                   | inode共享锁 |
| 写文件（不改变文件长度） | inode共享锁 |
| 写文件（改变文件长度）   | inode排他锁 |

inode需要一个标识来作为索引，防止多个inode实例同时存在。FTL OS使用了短文件名项的磁盘位置来作为标识，根目录的位置设为0。不使用inode首簇号作为标识的原因是FAT32文件系统的空文件不会分配簇。不使用索引的方式也是存在的，即由操作系统的虚拟文件系统层来保证inode的唯一性，但FTL OS未使用此方案。

### 目录操作

目录的操作包括插入、删除、查找三种操作。增加目录项和删除目录项都需获取inode排他锁，查找只需要获取inode共享锁。

查找项时输入为utf-8标准字符串，由于短文件名扩展等情况的存在同一字符串在FAT32文件系统可以有多种表示方式，不能提前判断输入字符串是否为短文件名，只能先根据文件名项生成文件名，再判断当前文件名与目标文件名是否匹配。文件名还需要判断是否包含保留字符，例如'<'、'>'等。

插入新的项需要先判断是否已经有存在的同名文件，并预先计算需要多少项文件名。计算完成后使用try方式遍历簇链寻找连续可用空间，如果找不到则在末尾分配新的簇。结束过程后在空闲位置写入即可。

删除项则需要找到文件名的位置，然后将每个项的首字母标记为0xE5。删除项分为删除目录和删除文件两种情况，锁定目录后将删除缓存管理器中的缓存，此后删除文件时将释放整个数据链，如果inode缓存存在其他的引用说明文件没有关闭，删除操作将失败。删除目录时只允许删除空目录，由上层操作负责递归删除整个目录。目录的排他锁保证了在删除过程中其他进程无法向删除目录中插入数据。

## 利用linux生成FAT32文件系统进行测试

使用mount系统调用可以把文件按指定文件系统挂载到一个目录上，挂载后即可和操作一样向文件系统写入数据了。把文件按文件系统格式化的指令为：

```shell
dd if=/dev/zero of=fat32.img bs=40M count=1mkfs.vfat -s 8 -F 32 fat32.img
```

`-s 8`指定了一个簇为8个扇区，`-F 32`指定了fat32文件系统而不是fat8或fat16。fat32文件系统的最小大小为32MB，小于或等于这个大小将创建失败。

使用mount挂载到一个目录下，这里设为img_test。

```shell
mkdir ./img_test
sudo mount -t vfat -o user,umask=000,utf8=1 --source fat32.img --target img_test
```

成功挂载后即可用touch、mkdir等指令在fat32.img内部按fat32标准创建文件，umount后fat32.img文件可以用来测试文件系统的正确性。

## 参考资料

fat32 wiki: [https://wiki.osdev.org/FAT](https://wiki.osdev.org/FAT)

FAT32文件系统结构详解 [https://blog.csdn.net/li_wen01/article/details/79929730](https://blog.csdn.net/li_wen01/article/details/79929730)

FAT32长文件名短文件名目录项 [https://blog.csdn.net/u010650845/article/details/60780979](https://blog.csdn.net/u010650845/article/details/60780979)

## 适配Linux

FAT32是为windows平台设计的，而windows下禁止删除被占用的文件，如果你尝试删除正在被占用的文件，windows会弹出一个方框让你不知所措。linux则不同，磁盘上的文件在任何时候都可以删除，即使某个程序依然在使用这个文件。当所有程序都释放这个文件的控制权后这个文件才会真正地在磁盘上被删除。

显而易见，采用windows方式删除文件的方案最大的好处是不用在操作系统中维护一系列复杂的数据结构来支持磁盘上的延后删除的操作，磁盘上的数据也不存在“消亡”状态。但我们要实现Linux标准的操作系统，那么必须支持延后的磁盘数据释放操作。

### 数据的延迟删除

FAT32中，文件的目录项完全掌握了它的所有权，它消失了就意味着文件没了。如果要实现延迟删除，就需要把目录项的删除和磁盘数据的删除分为两部分。当用户从目录删除被占用的文件时只有目录项会被删除，文件的数据链表并不会被清空，当文件析构时才会将数据链表归还给文件系统。

我们不需要对目录支持延迟释放操作，因为非空的目录的不可删除的。如果目录是空的，那么只要和普通方式一样删除后再禁止全部操作就行了。

FTL OS的FAT32文件系统采用异步驱动，因此文件的释放操作也是异步的，但显然我们的析构函数并不是异步的。那么我们应该怎么在析构函数中释放数据链表呢？~~最简单的方法就是不释放~~，我们可以在析构函数中创建一个用来释放文件的临时任务并发送给调度器，这样就可以释放数据链表了。

一个已经被删除的文件不能与文件系统的其他部分发生关系，因此我们要断开它和目录项之间的联系。我们把这个操作叫detach，即断开文件和目录树的关系。对于文件，它仅仅删除目录项中的数据，而对于目录，只是给自己添加一个标记来禁止之后对它的任何操作，磁盘数据依然会在rmdir时被删除。

