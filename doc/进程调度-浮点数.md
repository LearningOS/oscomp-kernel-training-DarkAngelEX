# 浮点与优化

开启浮点单元的流程概况如下：

* 在mstatus中开启浮点单元，此过程需要SBI代理。

* 设置sstatus中的浮点标志位为FS::Initial / FS::Clean。

* 正常保存寄存器。

多核下每个核都要启用浮点运算。

## 浮点寄存器保存优化

通过benchmark获知，hifive unmatched的CPU权限切换开销非常小（仅刷新流水线），主要开销为陷阱函数中的上下文保存与恢复。尽管hifive unmatched为双发射处理器，但访存端口只有1个，而浮点寄存器有32个，保存开销很大。如果能减少浮点寄存器保存的次数就能显著提高性能。

启用浮点后sstatus标志位中含有三种可能：init, clean, dirty。用户调用浮点运算时标志位会变为dirty。

FTL OS内核全局关闭浮点指令集，仅在浮点上下文保存时启用，保证操作系统内核态不使用浮点运算。FTL OS实现了如下懒优化：

* 浮点寄存器只在线程切换时保存。

* 不进入用户态时，不加载浮点寄存器。

以上的优化针对两种场景，第一种为连续不涉及线程切换的系统调用，例如反复获取pid。由于线程未切换，CPU浮点寄存器不会发生变化，因此也不需要保存与恢复。第二种优化的例子有两个进程通过管道传输传输大量数据，在数据传输结束前都不需要再次进入用户态，自然也不需要恢复浮点寄存器。

实现第一种优化的方式是将寄存器的保存推迟到上下文切换，实现第二种优化的方式是将寄存器的恢复推迟到进入用户态之前，并通过need_store和need_load两个标志位来决定是否需要触发寄存器的保存与恢复。当上下文发生切换时，need_load标志位将变为1，而离开用户态时need_store变为1，每次浮点寄存器的保存与恢复都会重置对应的标志位。

FTL OS实现了更进一步的优化，即用户不使用浮点指令时不保存浮点寄存器。实现原理为用户使用浮点指令后csr的fs标志位将变为dirty，此时将need_store设为1即可，否则保持不变。

### 参考

[华科xv6-k210 构建调试-浮点操作]: https://gitlab.eduxiji.net/retrhelo/xv6-k210/-/blob/scene/doc/%E6%9E%84%E5%BB%BA%E8%B0%83%E8%AF%95-%E6%B5%AE%E7%82%B9%E6%93%8D%E4%BD%9C.md