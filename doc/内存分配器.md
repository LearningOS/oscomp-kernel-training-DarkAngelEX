# 内存分配器

buddy内存分配器：

以2幂划分内存段，rust第三方库使用B树储存每一个2幂长度的内存区域，申请区域时先从本区域申请，否则向上级段申请。

TCmalloc优化：

在每个CPU对各个大小设置cache，从cache分配空间不需要锁。cache空时继续分配则从全局分配器调入一半cache。cache满时释放一半cache。

# 第三方库buddy_system_allocator实现

内部使用了侵入式单向链表LinkedList，直接使用分配的内存并在区域上放置指针。因此释放后的内存不能再次使用。也因为此，最小的内存块为8字节以放置指针(sizeof usize)。

32个LinkedList放置了大小从1 2 4 8...长度的内存块。显然长度小于8的链表永不使用，但占用的空间也不大。放置的内存空间都是对齐的。

分配内存时先将空间大小向上对齐到2的幂，再从此大小对应的链表开始搜索，找不到则继续向上搜。找到链表后取出这个链表，将这个链表分半成2个后放入下级链表，下级链表迭代直到分配空间大小的链表得到空间。（链表操作有潜在优化可能）现在待分配空间的链表已经有数据了，可从已经拥有空间的链表中返回链表。

释放空间时需要考虑空间归并。使用O(N)（很慢！！）遍历链表搜索伙伴块，如果找到则将空间释放。内存碎片会导致释放空间时耗费大量的时间。

## 可能的优化

### GC垃圾回收合并（最简单也可能最快）

每次释放内存都O(N)搜索太慢了，可以修改GC方式处理：对每个链表，设上一次GC后的长度为N，当释放内存使链表长度到达kN且kN大于某个常数C时调用GC合并段，k可以取1.5。合并段的方式为先整体排序，临时调入最大长度的连续内存，将整个链表写入这个段后使用随机访问的快速排序，合并完成后写回链表。如果连续内存空间不足，考虑使用链表上的快速排序，此排序可能会更慢。GC的时间复杂度是排序的O(NlogN)，平均复杂的降低至O(logN)。

可以以史诗级速度O(1)分配内存。且不会在大量重复分配释放时出现大量拆分合并。

在内存不足时强制触发一遍完整的GC。

### 基于区间的二叉树

单链表搜索太慢了，考虑使用二叉树全部内存段。使用二叉树则必须以动态内存方式分配节点，因为上级节点空间和下级节点的空间是重合的，没法复用。

节点至少需要包含两个指针指向两个子节点，可以用判空的方式判断有效，两个子节点都是空节点则此节点是根节点。二叉树保证任何节点的两个子节点不都是根节点。

为了提高效率，可以增加一个指针指向父节点，使节点合并时可以使用循环而不是递归。

节点对应的段指针事实上可以用逻辑方式计算，但这么做会导致每次分配空间时必须回溯到根节点来计算指针。可以直接把这个指针放在节点里，如此每个节点正好4个指针，需要16字节的空间。

管理空闲段：这些空闲段可以使用侵入式数据结构而不占用动态内存分配空间。

为了搜索某个长度的内存，需要指针直接指向某个长度的第一个有效段来分配内存。为了分配内存后更新此指针，考虑使用链表组织固定长度。由于释放内存导致的节点合并会移除节点，这会改变前一个节点的指针，考虑使用双向链表。

释放内存需要加入节点，需要方式在拿到地址时获得前后两个有效段并修改指针。可以用位域管理，例如二叉树最多64级，则在节点上增加一个64位标志，用来表示此区域以下是否存在某个长度的有效段。申请释放内存时向上遍历修改标志。

#### 数据结构

实现以上算法需要的数据结构需要7个数据 >> 64字节，每个4KB页可以放入64个节点。可以要求节点池的数量总是大于64，否则利用分配器分配64个节点放入节点池再分配。节点池永不归还内存。

左右子节点指针，父节点指针，指向的内存指针，有效段标志，两个双向链表的指针。

节点保证是根节点或子节点含根节点。

节点保证两个子节点不都是根节点。

#### 申请内存

1 计算固定段长度

2 获得双向链表头指针指向的节点

3 如果找不到，则向上找到第一个有效指针，分裂节点。

4 修改双向链表指向下一个有效段

5 向上删除无效节点，放回节点池

6 向上修改固定段对应的标志位

#### 释放内存

1 计算固定段长度

2 根据地址找到存在的底层节点并修改标志位，这个节点不是有效段，下级指针是0。

3 从节点池分配节点，不断插入二叉树并修改标志位，直到插入到有效段对应的节点。

4 再次从根节点遍历两次，利用标志位获取左右两个最近的有效段节点。

5 修改双向链表。

### 集合(B-Tree)代替链表

以集合的方式管理各个固定长度的段，即将原始方式从单链表替换为集合。树状数据结构会将释放内存的复杂度降低至O(logN)，但也将申请内存的时间复杂度提高至O(logN)。集合的节点需要动态内存分配。