# 内存分配器

常见内核都使用buddy伙伴内存分配器，它以2幂划分空闲内存至各个集合，分配内存时从对应大小的集合取出一块，如果不能取出则从上级集合分裂出对应大小的内存。释放时放回对应的集合，并判断集合中是否存在可以合并的另一块内存，如果存在则合并这两块空间，加入合并后对应的集合。

rCore-tutorial采用了第三方库的buddy_system_allocator分配器作为全局的堆分配器。此分配器使用链表管理同大小的集合，默认分配器内部的内存块不存在其他的引用，直接在每个内存块头部保存一个指针，利用此指针将各个内存连成链表，为了保存指针，最小的可分配空间为8字节。buddy_system_allocator释放内存的合并策略是扫描整条链表寻找伙伴，因此每次释放操作的时间复杂度是O(N)，内存碎片越多性能越低。

TCmalloc是google开发的高速内存分配器，使用线程缓存技术在每个线程放置了内存分配缓存，从分配缓存中分配内存不需要获取锁。

## FTL OS内存分配器实现

FTL OS希望构造一个高速的内存分配系统，希望兼顾性能和安全时尽可能简单。

rust保证了不使用unsafe时，智能指针管理的内存释放后保证不存在悬挂指针，因此内存分配器使用在内存块内放置指针的策略，保证不使用释放后的内存。

> 事实上，如果如C++一样在内存分配区域之前放置元信息会导致极大的空间开销，因为大部分分配的内存大小都是2的幂，如果分配大小增大一点点，分配器就会将其看作下一个幂，空间直接损耗了50%！

加入TCmalloc的优化很简单，只需要在每个CPU设置内存分配cache即可，cache空时继续分配则从全局分配器调入一半cache。cache满时释放一半cache。

## 内存释放优化

buddy_system_allocator的O(N)内存释放是不可接受的，是否有更高效的实现方法？

### GC垃圾回收合并

每次释放内存都O(N)搜索太慢了，可以修改GC方式处理：对每个链表，设上一次GC后的长度为N，当释放内存使链表长度到达kN且kN大于某个常数C时调用GC合并段，k可以取1.5。合并段的方式为先整体排序，临时调入最大长度的连续内存，将整个链表写入这个段后使用随机访问的快速排序，合并完成后写回链表。如果连续内存空间不足，考虑使用链表上的快速排序，此排序可能会更慢。GC的时间复杂度是排序的O(NlogN)，平均复杂的降低至O(logN)。

可以以史诗级速度O(1)分配内存。且不会在大量重复分配释放时出现大量拆分合并。

在内存不足时强制触发一遍完整的GC。

### 集合(B-Tree)代替链表

以集合的方式管理各个固定长度的段，即将原始方式从单链表替换为集合。树状数据结构会将释放内存的复杂度降低至O(logN)，但也将申请内存的时间复杂度提高至O(logN)。集合的节点需要使用其他动态分配的方式。
