## 信号

FTL OS信号系统参考自Linux，使用与Linux完全一致的接口，但部分选项未实现。

> 信号处理时原来的上下文保存在哪里？

信号处理函数可以打断原本的控制流，因此在处理信号时需要保存原来的上下文。FTL OS不希望只局限于简单的，无法无限嵌套的，需要在内核态分配内存的信号实现，因此使用了Linux中的方式：将原上下文保存在用户态，不在内核态记录原上下文信息，当处理函数结束后从用户态取出。

为了追踪原上下文，需要将此上下文的指针保存在内核态，当此指针改变时原指针会被压入上下文栈。

> 信号处理函数运行在哪个栈？

在Linux上测试信号处理，输出处理函数和main函数中一个局部变量的地址，发现这两个地址的差约300字节。这么小的地址差说明Linux处理信号并没有开辟新的栈空间，而是直接运行在原来的栈上。这样当然有局限性，例如当发生栈溢出时信号处理函数就没有位置运行了，因此Linux提供了修改信号运行栈的接口，允许让信号运行在另外的栈空间。

>如何让信号处理函数返回时进入内核态？

设置进入信号处理函数时的ra寄存器为sigreturn系统调用的地址，在用户地址空间映射一页信号跳板页，里面为sigreturn的入口。

> Linux如果同时收到多个信号，它是怎么处理的？

Linux允许不同信号嵌套，即当处理信号A时收到了信号B，则挂起A的流程直接开始处理B，前提是B没有被屏蔽。如果信号A没有处理完成前又收到了信号A，信号A不会发生递归而是等待当前信号A处理完成后再处理一次。这是因为信号处理时会屏蔽自身，如果手动关闭屏蔽位则可以发生同一个信号的嵌套处理。

信号处理开始前会将旧屏蔽位也压入栈，因此处理信号时修改的屏蔽位在处理完成后不再生效。

