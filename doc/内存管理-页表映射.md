# 页表映射

Hifive Unmatched开发板文档说明支持ASID，FTL OS也实现了基于ASID的地址空间切换优化。但实际上板测试中ASID无效，因此目前禁用了ASID优化并在页表操作前后增加了刷表指令。Hifive Unmatched开发板相比K210使用了更新版本的RISC-V指令集，在硬件上支持sfence.vma指令，不需要sbi代理，因此执行sfence.vma只需要刷新处理器流水线(约10时钟)，速度非常快。尽管如此开销大幅下降，但TLB未命中带来的开销依然较大。

FTL OS的页表同时映射了用户段和内核段，在用户态和内核态切换时不切换页表，只有在切换页表或页表修改时才需要刷表指令。

Hifive Unmatched开发板支持16 GB的内存，而内核入口地址为0x80200000。如果将0x80000000作为用户数据和内核数据的分界线，用户虚拟地址将只能获得2 GB的空间，单个进程无法充分利用16 GB的内存。为了充分使用硬件资源，FTL OS将内核段划分至0xffff_ffc0_0000_0000 - MAX，用户段划分至0x0 - 0x40_0000_0000，用户段和内核段都拥有256GB的空间，可以进行更进一步的划分。

## 进入内核

内核段重新映射后不可以从入口地址(0x80200000)直接call/j跳入内核入口函数，因为编译器的链接基址为0xffffffff80200000，在编译器看来运行在这里时PC=0xffffffff80200000，但实际上PC=0x80200000！能够正常运行仅仅是因为两个地址对齐了而已。普通的跳转方式使用auipc进行相对地址跳转，而从0x80200000地址相对跳转只能进入虚空。因此必须先将内核地址映射到高位地址，切换页表后再通过jr跳转至内核入口。

如何在entry函数中完成完整的高位内核映射？用汇编写一个页表映射函数？事实上sv39不仅支持4 KB的页映射，还支持2 MB和1 GB的巨页表映射。利用巨页表即可方便地将物理地址映射到高位地址空间：

```assembly
	# kernel/src/hart/boot/entry64.asm
	.align 12   # page align
boot_page_table_sv39:
    # 0x00000000_80000000 -> 0x80000000 (1G) 2 physical mapping
    # 0xfffffff0_80000000 -> 0x80000000 (1G) 450 kernel direct mapping offset
    # 0xffffffff_80000000 -> 0x80000000 (1G) 510 kernel link
    # -2- <2> -447- <450> -59- <510> -1
    .quad 0
    .quad 0
    .quad (0x80000 << 10) | 0xcf # VRWXAD
    .zero 8 * 447
    .quad (0x80000 << 10) | 0xcf # VRWXAD
    .zero 8 * 59
    .quad (0x80000 << 10) | 0xcf # VRWXAD
    .quad 0
```

boot页表在映射了高位地址的同时还保持了物理地址的直接映射，利用它就可以正常进入内核入口函数rust_main了。显然这个页表的映射太过于粗糙，因此需要在内存初始化中替代为更加精细的页表。

## 虚拟地址映射

sv39支持39位地址空间，寻址时高25位需要和第39位相同，否则将产生页错误。利用高位0/1划分为用户区和内存区，两个区域的地址空间都是256 GB。

### 内核段

| 描述                      | 起始地址              | 结束地址              |
| ------------------------- | :-------------------- | --------------------- |
| 全部映射(256 GB)          | 0xffff_ffc0_0000_0000 | MAX                   |
| 硬件IO地址(1 GB 未使用)   | 0xffff_ffff_c000_0000 | 0xffff_ffff_ffff_f000 |
| 内核数据段(1 GB)          | 0xffff_ffff_8000_0000 | 0xffff_ffff_c000_0000 |
| 直接内存映射(32 GB)       | 0xffff_fff0_0000_0000 | 0xffff_fff8_0000_0000 |
| 文件映射 (64 GB 未使用)   | 0xffff_ffd0_0000_0000 | 0xffff_ffe0_0000_0000 |
| 虚拟内存映射(64GB 未使用) | 0xffff_ffc0_0000_0000 | 0xffff_ffd0_0000_0000 |

### 用户段

| 描述              | 起始地址       | 结束地址       |
| ----------------- | -------------- | -------------- |
| 全部映射(256 GB)  | 0x0            | 0x40_0000_0000 |
| 链接基地址        | 0x10000        | 0x10000        |
| 数据段(32 GB)     | 0x10000        | 0x8_0000_0000  |
| 堆段(32 GB)       | 0x8_0000_0000  | 0x10_0000_0000 |
| 线程栈段 (64 GB)  | 0x10_0000_0000 | 0x20_0000_0000 |
| 文件映射 (128 GB) | 0x20_0000_0000 | 0x40_0000_0000 |

## 目录页表缓冲区

当我们分配一个页表的时候，不仅需要分配实际映射的物理内存，还需要映射到达这个物理内存的每个页表项。但是我们不能仅分配一块没有初始化的内存给页表，还需要把它给初始化为无效状态。对于fork，这个初始化操作反而成为了最大的开销，因为每次填充都会带来512次8字节访存！它的开销可不止512个时钟，还冲刷了hifive板子里16 KB的L1 DCache的四分之一，导致接下来的操作出现大量的Cache-miss，有没有什么办法可以降低它的开销呢？

理论上，如果我们根本不会访问到错误地址，那么页表不填充0也没关系，因为会使用到的页表项都在表内。但是这种做法无疑是非常危险的，如果用户访问了一个错误的未映射地址，而页表项的这个位置恰好V标志位是有效的，那它可能会被导向一个危险的物理地址，直接威胁整个系统的安全性。

FTL OS不想和其他队伍同流合污，因为安全性比性能更重要。注意到，当一个目录项被回收时，它的所有页表项也应该都处于无效状态。这给了我们发挥空间，如果我们让所有目录项都统一回收到同一个地方，那么当我们从这里分配内存时，可以保证它们的页表项全都是无效的。在初始化操作系统时，我们可以为这块缓存预分配空间，这样就不需要花费大量的时间去初始化目录页表了。

目录页表缓冲区永远不会回收到全局帧分配器，因为目录页表的需求非常少，对于lmbench程序，它进行一次fork只需要不到10个目录页表，这些目录页表在程序退出后可以立刻释放。

此优化让FTL OS的fork基准测试耗时从660us降低到341us。这个提升已经远远超出了复制开销，它的实际性能提升来源很可能是因为cache命中率提高了。
